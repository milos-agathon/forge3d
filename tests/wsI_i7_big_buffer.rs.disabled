//! Unit tests for I7 big buffer pattern (wsI_i7_big_buffer.rs)
//!
//! Tests alignment/padding, offset math, and microbench for 10k-object scenario.
//! Validates ≥25% improvement over per-object bind group path.

#[cfg(feature = "wsI_bigbuf")]
use forge3d::core::big_buffer::*;
#[cfg(feature = "wsI_bigbuf")]
use forge3d::core::memory_tracker::ResourceRegistry;
#[cfg(feature = "wsI_bigbuf")]
use forge3d::error::RenderError;

#[cfg(feature = "wsI_bigbuf")]
use wgpu::{Device, Queue, Buffer, BufferUsages, BufferDescriptor};
use pollster;

/// Test fixture for GPU testing
#[cfg(feature = "wsI_bigbuf")]
struct GpuTestContext {
    device: Device,
    queue: Queue,
}

#[cfg(feature = "wsI_bigbuf")]
impl GpuTestContext {
    async fn new() -> Result<Self, RenderError> {
        let instance = wgpu::Instance::new(wgpu::InstanceDescriptor::default());
        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions::default())
            .await
            .ok_or_else(|| RenderError::Device("Failed to find adapter".to_string()))?;

        let (device, queue) = adapter
            .request_device(&wgpu::DeviceDescriptor::default(), None)
            .await
            .map_err(|e| RenderError::Device(format!("Failed to create device: {}", e)))?;

        Ok(Self { device, queue })
    }
}

#[test]
fn test_big_buffer_constants() {
    assert_eq!(BIG_BUFFER_BLOCK_SIZE, 64);
    assert_eq!(BIG_BUFFER_MAX_SIZE, 128 * 1024 * 1024);
}

#[test]
fn test_alignment_math() {
    // Test alignment calculations
    assert_eq!(((32 + BIG_BUFFER_BLOCK_SIZE as u32 - 1) / BIG_BUFFER_BLOCK_SIZE as u32) * BIG_BUFFER_BLOCK_SIZE as u32, 64);
    assert_eq!(((64 + BIG_BUFFER_BLOCK_SIZE as u32 - 1) / BIG_BUFFER_BLOCK_SIZE as u32) * BIG_BUFFER_BLOCK_SIZE as u32, 64);
    assert_eq!(((65 + BIG_BUFFER_BLOCK_SIZE as u32 - 1) / BIG_BUFFER_BLOCK_SIZE as u32) * BIG_BUFFER_BLOCK_SIZE as u32, 128);
    assert_eq!(((127 + BIG_BUFFER_BLOCK_SIZE as u32 - 1) / BIG_BUFFER_BLOCK_SIZE as u32) * BIG_BUFFER_BLOCK_SIZE as u32, 128);
    assert_eq!(((128 + BIG_BUFFER_BLOCK_SIZE as u32 - 1) / BIG_BUFFER_BLOCK_SIZE as u32) * BIG_BUFFER_BLOCK_SIZE as u32, 128);
}

#[test]
fn test_offset_calculation() {
    // Test dynamic offset addressing helpers
    let block = BigBufferBlock {
        offset: 256,
        size: 64,
        index: 4,
        allocator: std::sync::Weak::new(),
    };

    assert_eq!(calculate_dynamic_offset(&block), 256);
    assert_eq!(calculate_index_address(&block), 4);
    
    // Verify index calculation is correct
    assert_eq!(block.offset / BIG_BUFFER_BLOCK_SIZE as u32, block.index);
}

#[cfg(feature = "wsI_bigbuf")]
#[tokio::test]
async fn test_big_buffer_creation() -> Result<(), RenderError> {
    let ctx = GpuTestContext::new().await?;
    let registry = ResourceRegistry::new();

    // Test valid sizes
    let buffer = BigBuffer::new(&ctx.device, 1024, Some(&registry))?;
    assert_eq!(buffer.size(), 1024);

    // Test size alignment (should round up to nearest block size)
    let buffer = BigBuffer::new(&ctx.device, 100, Some(&registry))?;
    assert_eq!(buffer.size(), 128); // Rounded up to 2 * 64

    // Test invalid sizes
    assert!(BigBuffer::new(&ctx.device, 0, Some(&registry)).is_err());
    assert!(BigBuffer::new(&ctx.device, (BIG_BUFFER_MAX_SIZE + 1) as u32, Some(&registry)).is_err());

    Ok(())
}

#[cfg(feature = "wsI_bigbuf")]
#[tokio::test]
async fn test_big_buffer_allocation() -> Result<(), RenderError> {
    let ctx = GpuTestContext::new().await?;
    let registry = ResourceRegistry::new();
    let buffer = BigBuffer::new(&ctx.device, 1024, Some(&registry))?;

    // Allocate some blocks
    let block1 = buffer.allocate_block(32)?;
    assert_eq!(block1.offset, 0);
    assert_eq!(block1.size, 64); // Aligned to block size
    assert_eq!(block1.index, 0);

    let block2 = buffer.allocate_block(48)?;
    assert_eq!(block2.offset, 64);
    assert_eq!(block2.size, 64);
    assert_eq!(block2.index, 1);

    let block3 = buffer.allocate_block(96)?;
    assert_eq!(block3.offset, 128);
    assert_eq!(block3.size, 128); // Aligned to 2 blocks
    assert_eq!(block3.index, 2);

    // Check memory stats
    let stats = buffer.memory_stats();
    assert_eq!(stats.total_bytes, 1024);
    assert_eq!(stats.allocated_blocks, 3);
    assert!(stats.used_bytes > 0);
    assert!(stats.free_bytes < stats.total_bytes);

    // Test allocation failure
    let result = buffer.allocate_block(1000); // Too big for remaining space
    assert!(result.is_err());

    Ok(())
}

#[cfg(feature = "wsI_bigbuf")]
#[tokio::test]
async fn test_big_buffer_deallocation() -> Result<(), RenderError> {
    let ctx = GpuTestContext::new().await?;
    let registry = ResourceRegistry::new();
    let buffer = BigBuffer::new(&ctx.device, 512, Some(&registry))?;

    // Allocate blocks
    let block1 = buffer.allocate_block(64)?;
    let block2 = buffer.allocate_block(64)?;
    let _block3 = buffer.allocate_block(64)?;

    let stats_before = buffer.memory_stats();
    assert_eq!(stats_before.allocated_blocks, 3);

    // Drop blocks to trigger deallocation
    drop(block1);
    drop(block2);

    // Force garbage collection by trying to allocate
    let _block4 = buffer.allocate_block(64)?;
    let stats_after = buffer.memory_stats();
    
    // Should have less fragmentation after deallocation
    assert!(stats_after.allocated_blocks <= stats_before.allocated_blocks);

    Ok(())
}

#[cfg(feature = "wsI_bigbuf")]
#[tokio::test] 
async fn test_big_buffer_fragmentation() -> Result<(), RenderError> {
    let ctx = GpuTestContext::new().await?;
    let registry = ResourceRegistry::new();
    let buffer = BigBuffer::new(&ctx.device, 1024, Some(&registry))?;

    // Create a fragmentation pattern
    let blocks: Vec<_> = (0..8).map(|_| buffer.allocate_block(64)).collect::<Result<Vec<_>, _>>()?;
    
    // Drop every other block to create holes
    for i in (0..blocks.len()).step_by(2) {
        drop(&blocks[i]);
    }

    let stats = buffer.memory_stats();
    assert!(stats.fragmentation_ratio > 0.0);
    assert!(stats.free_blocks > 1); // Should have multiple free blocks

    Ok(())
}

/// Microbenchmark comparing big buffer vs per-object bind groups (10k objects)
#[cfg(feature = "wsI_bigbuf")]
#[tokio::test]
async fn test_big_buffer_10k_microbench() -> Result<(), RenderError> {
    let ctx = GpuTestContext::new().await?;
    let registry = ResourceRegistry::new();
    
    const OBJECT_COUNT: u32 = 10_000;
    const OBJECT_DATA_SIZE: u32 = 64; // One matrix worth of data
    
    let start = std::time::Instant::now();
    
    // Big buffer approach: single large buffer
    let big_buffer = BigBuffer::new(
        &ctx.device, 
        OBJECT_COUNT * OBJECT_DATA_SIZE, 
        Some(&registry)
    )?;
    
    // Allocate blocks for all objects
    let mut blocks = Vec::with_capacity(OBJECT_COUNT as usize);
    for _ in 0..OBJECT_COUNT {
        blocks.push(big_buffer.allocate_block(OBJECT_DATA_SIZE)?);
    }
    
    let big_buffer_time = start.elapsed();
    
    // Per-object buffer approach: many small buffers  
    let start = std::time::Instant::now();
    let mut per_object_buffers = Vec::with_capacity(OBJECT_COUNT as usize);
    for _ in 0..OBJECT_COUNT {
        let buffer = ctx.device.create_buffer(&BufferDescriptor {
            label: Some("PerObjectBuffer"),
            size: OBJECT_DATA_SIZE as u64,
            usage: BufferUsages::STORAGE,
            mapped_at_creation: false,
        });
        per_object_buffers.push(buffer);
    }
    let per_object_time = start.elapsed();
    
    println!("Big buffer approach: {:?}", big_buffer_time);
    println!("Per-object buffer approach: {:?}", per_object_time); 
    
    // Big buffer should be significantly faster for allocation
    let improvement_ratio = per_object_time.as_nanos() as f64 / big_buffer_time.as_nanos() as f64;
    println!("Big buffer improvement ratio: {:.2}x", improvement_ratio);
    
    // Verify ≥25% improvement (1.25x faster)
    assert!(improvement_ratio >= 1.25, 
            "Big buffer should be ≥25% faster, got {:.2}x improvement", improvement_ratio);
    
    // Verify memory usage
    let stats = big_buffer.memory_stats();
    assert_eq!(stats.allocated_blocks, OBJECT_COUNT);
    assert_eq!(stats.total_bytes, OBJECT_COUNT * OBJECT_DATA_SIZE);
    
    // Verify all blocks are properly indexed
    for (i, block) in blocks.iter().enumerate() {
        assert_eq!(block.offset, i as u32 * OBJECT_DATA_SIZE);
        assert_eq!(block.index, i as u32);
        assert_eq!(block.size, OBJECT_DATA_SIZE);
    }
    
    Ok(())
}

/// Test bind group layout compatibility
#[cfg(feature = "wsI_bigbuf")]
#[tokio::test]
async fn test_big_buffer_bind_group_layout() -> Result<(), RenderError> {
    let ctx = GpuTestContext::new().await?;
    let registry = ResourceRegistry::new();
    let big_buffer = BigBuffer::new(&ctx.device, 1024, Some(&registry))?;

    // Create a bind group layout for storage buffer
    let bind_group_layout = ctx.device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("BigBufferBindGroupLayout"),
        entries: &[wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Storage { read_only: true },
                has_dynamic_offset: true, // Key for big buffer pattern
                min_binding_size: Some(std::num::NonZeroU64::new(BIG_BUFFER_BLOCK_SIZE).unwrap()),
            },
            count: None,
        }],
    });

    // Create bind group
    let bind_group = ctx.device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("BigBufferBindGroup"),
        layout: &bind_group_layout,
        entries: &[wgpu::BindGroupEntry {
            binding: 0,
            resource: wgpu::BindingResource::Buffer(wgpu::BufferBinding {
                buffer: big_buffer.buffer(),
                offset: 0,
                size: Some(std::num::NonZeroU64::new(BIG_BUFFER_BLOCK_SIZE).unwrap()),
            }),
        }],
    });

    // Test that we can create bind groups successfully
    assert!(!bind_group_layout.global_id().is_null());
    assert!(!bind_group.global_id().is_null());

    Ok(())
}

/// Test validation of WGSL compatibility
#[cfg(feature = "wsI_bigbuf")]
#[test]
fn test_wgsl_struct_alignment() {
    // Verify that our ObjectData struct in WGSL would be 64 bytes
    // mat4x4<f32> = 16 floats * 4 bytes = 64 bytes
    assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
    
    // This matches BIG_BUFFER_BLOCK_SIZE
    assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), BIG_BUFFER_BLOCK_SIZE as usize);
}