<Task name="A1.4 — Off-screen target & readback (loop-proof v3: read-only discovery, region-limited, no Replace)">
  <Policy>
    <!-- Absolute prohibitions to break loops -->
    - DO NOT use the "Replace" tool at all in this task. Only use:
      (a) InsertAfter / InsertBefore (with idempotent markers), and
      (b) RegexReplace (with negative lookaheads) AFTER region scoping is established.
    - Phase A (discovery) is STRICTLY read-only. Any attempt to write in Phase A must be aborted with:
      "PHASE A is read-only — write aborted."

    <!-- Region scoping before any edit -->
    - Before editing, locate and PRINT the function that contains the FIRST occurrence of
      `encoder.begin_render_pass` in each render path. Show the function header and an approximate line range.
    - Apply RegexReplace ONLY inside that function region; never apply a global file-wide replace.
      If more than one candidate region exists, print both with 15 lines of context and STOP (no guess).

    <!-- Idempotency + no-op guard -->
    - Wrap any inserted block with markers: `// A1.4-BEGIN: <name>` ... `// A1.4-END: <name>`.
    - For every edit, compute the proposed new content in memory. If it would be byte-identical:
      print "Already correct — skipping Update" and DO NOT call Update.

    <!-- Per-edit error stoplist (one retry then skip) -->
    - If any tool returns an error that contains one of:
        * "No changes to make"
        * "String to replace not found"
        * "Found " and " matches " and " replace_all is false"
      then:
        1) Print 15 lines of nearest context around the intended anchor,
        2) Retry ONCE with a narrower, region-scoped RegexReplace (or skip if not safe),
        3) If it fails again, print "SKIPPED: anchor not uniquely resolvable" and DO NOT attempt that edit again.
    - Cap total Update calls to 6. If reached, STOP and summarize which edits were applied/skipped.

    <!-- Allowed mutations for A1.4 only -->
    - Add fields to `pub struct Renderer` (A1.4 markers).
    - Add helpers: `align256`, `ensure_offscreen_target`, `ensure_readback_buffer`,
      `copy_texture_to_rgba_unpadded` (A1.4 markers).
    - In BOTH render paths, insert a short block BEFORE the first `encoder.begin_render_pass`
      in that function to call `ensure_offscreen_target` and bind `color_tex/view` (A1.4 markers).
    - Replace ONLY the readback call and the PNG `from_raw(..., bytes)` argument to use the helper,
      with RegexReplace guarded by negative lookaheads so you do not re-replace already-correct code.

    <!-- Do-not-touch -->
    - Never target generic descriptor fields such as:
      `dimension: wgpu::TextureDimension::D2,`, `size: wgpu::Extent3d { ... }`,
      `mip_level_count:`, `sample_count:`. Create the off-screen descriptor solely inside
      `ensure_offscreen_target`.

    <!-- Diffs & acceptance evidence -->
    - After edits, run `git status --porcelain`. For each changed file, print a FULL unified diff.
      If nothing changed, print "No changes required".
    - Preserve A1.2/A1.3 invariants: TEXTURE_FORMAT=Rgba8UnormSrgb, no MSAA, blend: None,
      CLEAR_COLOR, fixed viewport/scissor, linear interpolation, CCW+Back cull.
  </Policy>

  <Context>
    Files:
      - src/lib.rs (all A1.4 edits live here)
      - src/shaders/triangle.wgsl (no change expected)
  </Context>

  <!-- =================== PHASE A — READ-ONLY DISCOVERY =================== -->
  <Requests>
    <Request id="A1" description="Locate edit regions and anchors in src/lib.rs">
      <Action>
        - Open src/lib.rs.
        - Print ~20 lines around each:
          (1) `encoder.begin_render_pass` and the surrounding `RenderPassColorAttachment`,
          (2) any `copy_texture_to_buffer` / `ImageCopyBuffer` / `map_async` / `get_mapped_range`.
        - Print the full `pub struct Renderer` fields.
        - Print the constructor lines where render target `format:` is set.
        - Do NOT modify files in this phase (abort any write attempt).
      </Action>
    </Request>
  </Requests>

  <!-- =================== PHASE B — GUARDED, REGION-LIMITED, IDEMPOTENT EDITS =================== -->
  <Edits>
    <!-- 1) Fields (idempotent markers) -->
    <File path="src/lib.rs" intent="Add A1.4 fields">
      <InsertAfter anchor="pub struct Renderer" occurrence="first" if-not-present-contains="A1.4-BEGIN: fields">
<![CDATA[
// A1.4-BEGIN: fields
    color_tex: wgpu::Texture,
    color_view: wgpu::TextureView,
    readback_buf: wgpu::Buffer,
    readback_size: u64,
// A1.4-END: fields
]]>
      </InsertAfter>
    </File>

    <!-- 2) Helpers (idempotent markers) -->
    <File path="src/lib.rs" intent="Add A1.4 helpers">
      <InsertAfter anchor="use wgpu::util::DeviceExt;" occurrence="first" if-not-present-contains="A1.4-BEGIN: helpers">
<![CDATA[
// A1.4-BEGIN: helpers
fn align256(n: u32) -> u32 { ((n + 255) / 256) * 256 }

impl Renderer {
    fn ensure_offscreen_target(&mut self, device: &wgpu::Device, width: u32, height: u32) {
        let desc = wgpu::TextureDescriptor {
            label: Some("offscreen-color"),
            size: wgpu::Extent3d { width, height, depth_or_array_layers: 1 },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: TEXTURE_FORMAT,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::COPY_SRC,
            view_formats: &[],
        };
        let recreate =
            self.color_tex.size().width != width ||
            self.color_tex.size().height != height ||
            self.color_tex.format() != TEXTURE_FORMAT;
        if recreate {
            self.color_tex = device.create_texture(&desc);
            self.color_view = self.color_tex.create_view(&wgpu::TextureViewDescriptor::default());
        }
    }

    fn ensure_readback_buffer(&mut self, device: &wgpu::Device, size_bytes: u64) {
        if self.readback_size >= size_bytes { return; }
        self.readback_buf = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("readback-buffer"),
            size: size_bytes,
            usage: wgpu::BufferUsages::COPY_DST | wgpu::BufferUsages::MAP_READ,
            mapped_at_creation: false,
        });
        self.readback_size = size_bytes;
    }
}
// A1.4-END: helpers
]]>
      </InsertAfter>
    </File>

    <!-- 3) Readback helper (idempotent markers) -->
    <File path="src/lib.rs" intent="Add readback helper">
      <InsertAfter anchor="use wgpu::util::DeviceExt;" occurrence="first" if-not-present-contains="A1.4-BEGIN: readback">
<![CDATA[
// A1.4-BEGIN: readback
impl Renderer {
    fn copy_texture_to_rgba_unpadded(
        &mut self,
        device: &wgpu::Device,
        queue: &wgpu::Queue,
        tex: &wgpu::Texture,
        width: u32,
        height: u32,
    ) -> pyo3::PyResult<Vec<u8>> {
        let row_bytes = width * 4;
        let padded_bpr = align256(row_bytes);
        let size_bytes = padded_bpr as u64 * height as u64;
        self.ensure_readback_buffer(device, size_bytes);

        let mut encoder = device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: Some("copy-encoder") });
        let copy_src = wgpu::ImageCopyTexture { texture: tex, mip_level: 0, origin: wgpu::Origin3d::ZERO, aspect: wgpu::TextureAspect::All };
        let copy_dst = wgpu::ImageCopyBuffer {
            buffer: &self.readback_buf,
            layout: wgpu::ImageDataLayout {
                offset: 0,
                bytes_per_row: std::num::NonZeroU32::new(padded_bpr),
                rows_per_image: std::num::NonZeroU32::new(height),
            },
        };
        let extent = wgpu::Extent3d { width, height, depth_or_array_layers: 1 };
        encoder.copy_texture_to_buffer(copy_src, copy_dst, extent);
        queue.submit([encoder.finish()]);
        device.poll(wgpu::Maintain::Wait);

        let slice = self.readback_buf.slice(..);
        futures::executor::block_on(slice.map_async(wgpu::MapMode::Read))
            .map_err(|_| pyo3::exceptions::PyRuntimeError::new_err("MapAsync failed"))?;
        let data = slice.get_mapped_range();

        let mut out = vec![0u8; (row_bytes * height) as usize];
        let src_stride = padded_bpr as usize;
        let dst_stride = row_bytes as usize;
        for y in 0..(height as usize) {
            let src_off = y * src_stride;
            let dst_off = y * dst_stride;
            out[dst_off..dst_off + dst_stride].copy_from_slice(&data[src_off..src_off + dst_stride]);
        }
        drop(data);
        self.readback_buf.unmap();
        Ok(out)
    }
}
// A1.4-END: readback
]]>
      </InsertAfter>
    </File>

    <!-- 4) Function-scoped inserts + guarded replaces (region-limited) -->
    <File path="src/lib.rs" intent="Use off-screen + helper in each render path (region-limited)">
      <!-- Insert ensure_offscreen BEFORE the FIRST begin_render_pass inside the current function only -->
      <InsertBefore anchor="encoder.begin_render_pass" occurrence="first" if-not-present-contains="A1.4-BEGIN: ensure-offscreen">
<![CDATA[
// A1.4-BEGIN: ensure-offscreen
self.ensure_offscreen_target(&device, self.width, self.height);
let texture = self.color_tex.clone();
let view = self.color_view.clone();
// A1.4-END: ensure-offscreen
]]>
      </InsertBefore>

      <!-- Replace readback call only if NOT already our helper (guarded with negative lookahead) -->
      <RegexReplace
        pattern="let\s+pixels\s*=\s*(?!self\.copy_texture_to_rgba_unpadded\()[^;]*;"
        with="let pixels = self.copy_texture_to_rgba_unpadded(&device, &queue, &texture, self.width, self.height)?;"
        multiple="true"
      />

      <!-- Replace PNG from_raw(.., bytes) only if NOT already our helper -->
      <RegexReplace
        pattern="image::RgbaImage::from_raw\(\s*self\.width\s*,\s*self\.height\s*,\s*(?!self\.copy_texture_to_rgba_unpadded\()[^)]*\)"
        with="image::RgbaImage::from_raw(self.width, self.height, self.copy_texture_to_rgba_unpadded(&device, &queue, &texture, self.width, self.height)?)"
        multiple="true"
      />
    </File>
  </Edits>

  <!-- =================== PHASE C — BUILD & EVIDENCE =================== -->
  <Commands shell="bash">
    <Run>python -m pip install -U pip maturin</Run>
    <Run>export PYO3_USE_ABI3_FORWARD_COMPATIBILITY=1; maturin develop --release</Run>
    <Run>python -m examples.triangle</Run>
    <Run>python - <<'PY'\nimport numpy as np\nfrom vulkan_forge import Renderer\nr = Renderer(512,512)\na = r.render_triangle_rgba()\nprint('shape:', a.shape, 'dtype:', a.dtype)\nassert a.shape == (512,512,4) and a.dtype == np.uint8\nprint('OK: A1.4 acceptance: shape/dtype correct')\nPY</Run>
    <Run>git status --porcelain || true</Run>
    <Run>CHANGED=$(git status --porcelain | awk '{print $2}'); if [ -n "$CHANGED" ]; then for f in $CHANGED; do echo "### DIFF: $f"; git --no-pager diff --unified=3 -- "$f"; echo; done; else echo "No changes required"; fi</Run>
  </Commands>

  <Acceptance>
    <Criterion>No "Replace" tool calls are made; only Insert*/RegexReplace are used.</Criterion>
    <Criterion>No writes occur in Phase A. Any attempted write is aborted with a clear message.</Criterion>
    <Criterion>On any of the three loop errors, each edit is retried once with region scoping, then skipped.</Criterion>
    <Criterion>Updates are skipped when the patch would be empty ("Already correct — skipping Update").</Criterion>
    <Criterion>Off-screen color target + persistent readback buffer added once (markers present); both render paths use the helper.</Criterion>
    <Criterion>Full unified diffs for all changed files OR "No changes required".</Criterion>
  </Acceptance>
</Task>
