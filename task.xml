<Task id="T11-fix-winding" name="Fix grid index winding to +Y CCW and verify" version="1.0">
  <Meta>
    <Conventions>
      <Marker rust="// T11-BEGIN:* … // T11-END:*"/>
      <Rule>Always show unified diffs for changes. Edits must be idempotent.</Rule>
      <Rule>If an anchor is ambiguous/missing, show a 10-line context and propose a safe insertion—do not loop.</Rule>
    </Conventions>
  </Meta>

  <Phase id="A" name="Discovery (read-only)">
    <Read path="src/grid.rs"/>
    <Read path="src/lib.rs"/>
    <Read path="tests/test_grid_generator.py" optional="true"/>
    <Output>
      <Require>
        Confirm current tri ordering in src/grid.rs is [i0,i1,i3, i0,i3,i2] and that tests expect +Y normal for the first triangle.
      </Require>
    </Output>
  </Phase>

  <Phase id="B" name="Fix winding (idempotent)">
    <Update path="src/grid.rs" kind="replace_between" show_diff="true">
      <BeginMarker>// T11-BEGIN:generator</BeginMarker>
      <EndMarker>// T11-END:generator</EndMarker>
      <Content><![CDATA[
// T11-BEGIN:generator
/// Generate a regular grid of `nx` by `nz` vertices (columns x rows).
/// spacing = (dx, dz). nx>=2, nz>=2 enforced by caller.
/// Winding: CCW when looking from +Y toward origin.
/// UVs: u in [0,1] along x, v in [0,1] along z.
pub fn generate_grid(nx: u32, nz: u32, spacing: (f32, f32), origin: GridOrigin) -> GridMesh {
    assert!(nx >= 2 && nz >= 2, "nx, nz must be >= 2");
    let (dx, dz) = spacing;
    assert!(dx > 0.0 && dz > 0.0, "spacing must be > 0");

    let w = (nx - 1) as f32 * dx;
    let d = (nz - 1) as f32 * dz;

    let (x0, z0) = match origin {
        GridOrigin::Center   => (-0.5 * w, -0.5 * d),
        GridOrigin::MinCorner => (0.0, 0.0),
    };

    let mut vertices = Vec::with_capacity((nx * nz) as usize);
    let up = [0.0_f32, 1.0_f32, 0.0_f32];

    for j in 0..nz {
        let z = z0 + j as f32 * dz;
        let v = if nz > 1 { j as f32 / (nz - 1) as f32 } else { 0.0 };
        for i in 0..nx {
            let x = x0 + i as f32 * dx;
            let u = if nx > 1 { i as f32 / (nx - 1) as f32 } else { 0.0 };
            vertices.push(GridVertex { pos: [x, 0.0, z], nrm: up, uv: [u, v] });
        }
    }

    // Indices (CCW, +Y normal):
    // tri1: (i,j) -> (i,j+1) -> (i+1,j)
    // tri2: (i+1,j) -> (i,j+1) -> (i+1,j+1)
    let mut indices = Vec::with_capacity(((nx - 1) * (nz - 1) * 6) as usize);
    for j in 0..(nz - 1) {
        for i in 0..(nx - 1) {
            let i0 = j * nx + i;
            let i1 = i0 + 1;
            let i2 = i0 + nx;
            let i3 = i2 + 1;
            indices.extend_from_slice(&[
                i0, i2, i1, // tri1 (CCW, +Y)
                i1, i2, i3, // tri2 (CCW, +Y)
            ]);
        }
    }

    GridMesh { vertices, indices }
}
// T11-END:generator
      ]]></Content>
    </Update>
  </Phase>

  <Phase id="C" name="Build & Test">
    <Run shell="bash" show_output="true"><![CDATA[
if python - <<'PY' | grep -q True; then export PYO3_USE_ABI3_FORWARD_COMPATIBILITY=1; fi
import sys; print(sys.version_info[:2] >= (3,13))
PY
maturin develop --release
pytest -q -k grid_generator
    ]]></Run>
    <Acceptance>
      <Check>tests/test_grid_generator.py passes; first triangle normal has positive Y.</Check>
      <Check>All changes shown as diffs; T11 markers preserved; no loops.</Check>
    </Acceptance>
  </Phase>
</Task>
