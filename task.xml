You are Claude Code acting in **Safe Refactor Mode**.

OBJECTIVE
Rename the package across the entire repo:
- Textual/package name: **vulkan-forge → forge3d**
- Python module/crate name where applicable: **vulkan_forge → forge3d**
- Python import alias (only when aliasing the package): **vf → f3d**

SCOPE & CONSTRAINTS
- Update code, build files, docs, CI, examples, and packaging metadata.
- Be **scope-aware** for Python: only rename `vf` to `f3d` when `vf` is the alias bound to (or derived from) the package import; do not touch unrelated `vf` variables.
- Avoid changing third-party references or binary files. Exclude: `.git/`, `dist/`, `build/`, `.venv/`, `venv/`, `node_modules/`, `__pycache__/`, `*.png`, `*.jpg`, `*.pdf`, `*.whl`, `*.zip`, `*.tar.gz`.
- Preserve formatting and comments.

PLAN
1) Create a working branch and inventory all occurrences.
2) Perform structured renames in metadata/build files.
3) Rename Python import module and alias via an **AST-based** transformer (libcst).
4) Rename Rust/PyO3 or pybind11 module names and build targets.
5) Update docs/README/examples and CI.
6) Run tests/linters, then commit with a clear message and summary.

DETAILS

A) INVENTORY (dry run)
- Run ripgrep to list occurrences (case-sensitive and insensitive) and show counts:

```

rg -n --stats --hidden -g '!.git' -g '!dist' -g '!build' -g '!.venv' -g '!venv' -g '!node\_modules' -g '!**pycache**' -g '!*.png' -g '!*.jpg' -g '!*.pdf' -g '!*.whl' -g '!*.zip' -g '!*.tar.gz'&#x20;
-e '\bvulkan\[-\_ ]forge\b' -e '\bVulkan\[-\_ ]Forge\b' -e '\bVULKAN\[\_ ]FORGE\b' -e '\bvulkan\_forge\b' -e '\bforge3d\b' -e '\bimport +vulkan\_forge\b' -e '\bfrom +vulkan\_forge\b' -e '\bas +vf\b'

````

B) GIT SAFETY
- `git checkout -b chore/rename-forge3d`
- After changes, commit logically: metadata, code, docs.

C) METADATA / BUILD FILES (textual, not AST)
Update where present:
- `pyproject.toml`, `setup.cfg`, `setup.py`:
- project name → `forge3d`
- module/package import name → `forge3d`
- console scripts, entry points, package data, classifiers referencing old name
- `Cargo.toml` (if PyO3/Rust exists):
- `[package] name = "forge3d"` (was `vulkan-forge`)
- `[lib] name = "forge3d"` (was `vulkan_forge`)
- `CMakeLists.txt`, `Find*.cmake`, target names:
- `vulkan-forge` targets/vars → `forge3d`
- Docs/CI:
- README, docs, examples, badges, install snippets (`pip install forge3d`)
- GitHub Actions / CI scripts referencing old wheel/package name

D) PYTHON CODE REWRITE (AST, scope aware)
- For every `*.py`, perform:
1. Rename **module** references from `vulkan_forge` → `forge3d` in import statements.
2. If the import **aliases** the package as `vf`, rename the alias to `f3d` and **rename all bound references** to that alias in the module scope only.
3. Do **not** rename `vf` if:
   - It is not importing `vulkan_forge` / `forge3d`
   - It’s defined later as a variable/function/arg
- Handle patterns:
- `import vulkan_forge as vf` → `import forge3d as f3d`
- `from vulkan_forge import api as vf` → `from forge3d import api as f3d`
- `import vulkan_forge` → `import forge3d`
- `from vulkan_forge import X, Y` → `from forge3d import X, Y`
- Then rename **uses** of `vf.*` / `vf(...)` / `vf` identifier to `f3d` where `vf` is the alias bound to that import.

Create and run this libcst script from repo root:

```bash
python - <<'PY'
import sys, pathlib, json
from typing import Optional, Set
import libcst as cst
import libcst.matchers as m

ROOT = pathlib.Path(".")
PY_FILES = [p for p in ROOT.rglob("*.py") if all(part not in p.parts for part in (".git","dist","build",".venv","venv","node_modules","__pycache__"))]

OLD_MOD = "vulkan_forge"
NEW_MOD = "forge3d"
OLD_ALIAS = "vf"
NEW_ALIAS = "f3d"

class ImportAliasTransformer(cst.CSTTransformer):
  def __init__(self):
      # Track whether this module binds OLD_ALIAS from OLD_MOD/NEW_MOD
      self.binds_old_alias = False
      self.bound_name: Optional[str] = None

  def leave_Import(self, original_node: cst.Import, updated_node: cst.Import) -> cst.Import:
      names = []
      for name in updated_node.names:
          if m.matches(name, m.ImportAlias(name=m.Attribute() | m.Name(OLD_MOD))):
              # import vulkan_forge [as ...]
              base = name
              new_name = cst.ImportAlias(name=cst.Name(NEW_MOD), asname=base.asname)
              if base.asname and base.asname.name.value == OLD_ALIAS:
                  new_name = new_name.with_changes(asname=cst.AsName(cst.Name(NEW_ALIAS)))
                  self.binds_old_alias = True
                  self.bound_name = OLD_ALIAS
              names.append(new_name)
          else:
              names.append(name)
      return updated_node.with_changes(names=names)

  def leave_ImportFrom(self, original_node: cst.ImportFrom, updated_node: cst.ImportFrom) -> cst.ImportFrom:
      # from vulkan_forge[.sub] import ...
      if original_node.module and m.matches(original_node.module, m.Name(OLD_MOD)):
          mod = cst.Name(NEW_MOD)
      elif original_node.module and m.matches(original_node.module, m.Attribute(
          value=m.Name(OLD_MOD)
      )):
          # from vulkan_forge.something import ...
          # Convert only the root
          attr = original_node.module
          while isinstance(attr, cst.Attribute) and isinstance(attr.value, cst.Attribute):
              attr = attr.value
          if isinstance(original_node.module, cst.Attribute) and isinstance(original_node.module.value, cst.Name) and original_node.module.value.value == OLD_MOD:
              mod = cst.Attribute(value=cst.Name(NEW_MOD), attr=original_node.module.attr)
          else:
              mod = updated_node.module
      else:
          mod = updated_node.module

      # detect "as vf" on the imported names; if present, rename alias to f3d
      names = updated_node.names
      if isinstance(names, list):
          new_names = []
          for n in names:
              if isinstance(n, cst.ImportAlias) and n.asname and n.asname.name.value == OLD_ALIAS:
                  new_names.append(n.with_changes(asname=cst.AsName(cst.Name(NEW_ALIAS))))
                  self.binds_old_alias = True
                  self.bound_name = OLD_ALIAS
              else:
                  new_names.append(n)
          names = new_names

      return updated_node.with_changes(module=mod, names=names)

  def leave_Name(self, original_node: cst.Name, updated_node: cst.Name) -> cst.CSTNode:
      # If alias was bound in this module, rewrite references
      if self.binds_old_alias and original_node.value == OLD_ALIAS:
          return updated_node.with_changes(value=NEW_ALIAS)
      return updated_node

changed = 0
for path in PY_FILES:
  src = path.read_text(encoding="utf-8")
  try:
      mod = cst.parse_module(src)
  except Exception:
      continue
  xform = ImportAliasTransformer()
  new = mod.visit(xform)
  if new.code != src:
      path.write_text(new.code, encoding="utf-8")
      changed += 1

print(json.dumps({"python_files_rewritten": changed}, indent=2))
PY
````

E) C/C++/Rust BINDING POINTS

* **PyO3**: rename `#[pymodule] fn vulkan_forge(...)` → `#[pymodule] fn forge3d(...)`
* **pybind11**: rename `PYBIND11_MODULE(vulkan_forge, m)` → `PYBIND11_MODULE(forge3d, m)`
* Ensure the produced extension module filename matches `forge3d` (update build config accordingly).

F) DOCS / EXAMPLES

* Update README/docs snippets: `import forge3d as f3d`; update any `vf.` usage to `f3d.` where tied to the import alias.

G) CI / PACKAGING

* Update wheel build metadata (project name, tags), sdist settings, manylinux/macos/windows jobs, and upload targets.
* If publishing, update `project.urls`, badges, and package index references.

H) ACCEPTANCE CRITERIA (run these checks)

1. `rg -n '\bvulkan[-_ ]forge\b|\bvulkan_forge\b'` → **no matches** (excluding changelogs).
2. `rg -n '\bimport +vulkan_forge\b|\bfrom +vulkan_forge\b'` → **no matches**.
3. `rg -n '\bas +vf\b'` where tied to package imports → **no matches**.
4. In a fresh venv: `python -c "import forge3d as f3d; print(hasattr(f3d,'__doc__'))"` returns `True`.
5. All tests/linters pass: `pytest -q` (if present), `ruff --quiet .` or `flake8`, and any `mypy` config.
6. Build succeeds: sdist + wheel produce `forge3d` extension/module.

I) COMMIT

* Commit in logical steps with messages like:

  * `chore(rename): package vulkan-forge → forge3d (metadata/build/docs)`
  * `refactor(python): alias vf → f3d via AST; rename module vulkan_forge → forge3d`
  * `ci(packaging): update wheels and publishing targets to forge3d`
* At the end, post a brief summary of files changed and counts of rewritten Python files from the script output.

BEGIN.
