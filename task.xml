<task>
  <id>fix-pyo3-numpy-signatures</id>
  <owner>Claude Code</owner>
  <priority>P0</priority>
  <summary>Fix maturin build errors caused by using &PyReadonlyArray2<T> in #[pyfunction] signatures (pyo3 0.21 expects owned PyReadonlyArray2<'py, T> that implements FromPyObject).</summary>

  <context>
    <problem>
      <![CDATA[
      error[E0277]: the trait bound `&PyReadonlyArray<'_, f64, Dim<[usize; 2]>>: PyFunctionArgument<'_, '_>` is not satisfied
      note: required for `&PyReadonlyArray<'_, f64, Dim<[usize; 2]>>` to implement `pyo3::FromPyObject<'_>`
      ...
      Similar errors for:
        - holes: Option<Vec<&PyReadonlyArray2<f64>>>
        - path_coords: &PyReadonlyArray2<f64>
        - positions: &PyReadonlyArray2<f64>
        - nodes: &PyReadonlyArray2<f64>
        - edges: &PyReadonlyArray2<u32>
      ]]>
    </problem>
    <root_cause>
      <![CDATA[
      In pyo3 0.21, function parameters extracted from Python must implement FromPyObject. The owned handle types (e.g., PyReadonlyArray2<'py, T>) implement this, but references to them (&PyReadonlyArray2<T>) do not (references only work for PyClass types). Hence, pyo3 cannot extract &PyReadonlyArray2<T> and compilation fails.
      ]]>
    </root_cause>
    <goal>
      <![CDATA[
      Replace all &PyReadonlyArray2<T> parameters with owned PyReadonlyArray2<'py, T> (and Vec<&PyReadonlyArray2<T>> with Vec<PyReadonlyArray2<'py, T>>), add the required 'py lifetime, ensure proper imports, and make the crate compile with maturin.
      ]]>
    </goal>
  </context>

  <changeset>
    <!-- 1) Cargo.toml sanity (no version bumps if already present; only add missing bits) -->
    <file path="Cargo.toml" action="patch">
      <![CDATA[
      *** Begin Patch
      *** Update File: Cargo.toml
      @@
      [lib]
      crate-type = ["cdylib"]
      @@
      [dependencies]
      pyo3 = { version = "0.21", features = ["extension-module"] }
      numpy = "0.21"
      ndarray = "0.15"
      *** End Patch
      ]]>
    </file>

    <!-- 2) Ensure correct imports in src/vector/api.rs -->
    <file path="src/vector/api.rs" action="patch">
      <![CDATA[
      *** Begin Patch
      *** Update File: src/vector/api.rs
      @@
      -use numpy::PyReadonlyArray2;
      +use numpy::PyReadonlyArray2;
      +use pyo3::prelude::*;
      *** End Patch
      ]]>
    </file>

    <!-- 3) Fix all offending #[pyfunction] signatures in src/vector/api.rs -->
    <!-- Use explicit patches for the reported line regions; if names differ, apply the same transformation pattern. -->
    <file path="src/vector/api.rs" action="patch">
      <![CDATA[
      *** Begin Patch
      *** Update File: src/vector/api.rs
      @@
     -#[pyfunction]
     -pub fn <FUNCTION_AT_372>() -> Option<Vec<&PyReadonlyArray2<f64>>> { /* placeholder from error context */ }
     +// NOTE: Replace references with owned PyReadonlyArray2<'py, T> and introduce the 'py lifetime.
     +// For every #[pyfunction] that accepts numpy arrays, ensure the signature follows this pattern:
     +//   #[pyfunction]
     +//   pub fn func_name<'py>(/* optionally: _py: Python<'py>, */ arr: PyReadonlyArray2<'py, f64>, ...)
     +// References (&PyReadonlyArray2<T>) must be removed.
     *** End Patch
      ]]>
    </file>

    <!-- 3a) Concrete replacements around the lines noted by the compiler (apply globally in this file). -->
    <file path="src/vector/api.rs" action="regex-replace">
      <pattern>&\s*PyReadonlyArray2\s*<\s*f64\s*></pattern>
      <replacement>PyReadonlyArray2&lt;'py, f64&gt;</replacement>
      <multiple>true</multiple>
    </file>
    <file path="src/vector/api.rs" action="regex-replace">
      <pattern>&\s*PyReadonlyArray2\s*<\s*u32\s*></pattern>
      <replacement>PyReadonlyArray2&lt;'py, u32&gt;</replacement>
      <multiple>true</multiple>
    </file>
    <file path="src/vector/api.rs" action="regex-replace">
      <pattern>Vec\s*<\s*&\s*PyReadonlyArray2\s*<\s*f64\s*>\s*></pattern>
      <replacement>Vec&lt;PyReadonlyArray2&lt;'py, f64&gt;&gt;</replacement>
      <multiple>true</multiple>
    </file>

    <!-- 3b) Add 'py lifetime to any function using PyReadonlyArray2 that lacks it. -->
    <!-- Heuristic: insert <'py> after fn name if a parameter uses PyReadonlyArray2<'py, -->
    <file path="src/vector/api.rs" action="regex-replace">
      <pattern>(#[ \t]*pyfunction[^\n]*\n[ \t]*(?:pub[ \t]+)?fn[ \t]+([A-Za-z0-9_]+)\s*\()</pattern>
      <replacement>\1<'py>(</replacement>
      <multiple>true</multiple>
    </file>

    <!-- 3c) If any of those functions still lack a 'py source for lifetime inference, add an unused Python<'py> arg as first param. -->
    <file path="src/vector/api.rs" action="regex-replace">
      <pattern>(#[ \t]*pyfunction[^\n]*\n[ \t]*(?:pub[ \t]+)?fn[ \t]+[A-Za-z0-9_]+<'py>\s*\()</pattern>
      <replacement>\0_py: Python<'py>, </replacement>
      <multiple>true</multiple>
    </file>

    <!-- 3d) Concrete examples for the lines reported in the compiler errors (adjust names if different). -->
    <file path="src/vector/api.rs" action="patch">
      <![CDATA[
      *** Begin Patch
      *** Update File: src/vector/api.rs
      @@
     -// around line 372..376
     -#[pyfunction]
     -pub fn build_polygon(
     -    exterior_coords: &PyReadonlyArray2<f64>,
     -    holes: Option<Vec<&PyReadonlyArray2<f64>>>,
     -) -> PyResult<PyObject> {
     +#[pyfunction]
     +pub fn build_polygon<'py>(
     +    _py: Python<'py>,
     +    exterior_coords: PyReadonlyArray2<'py, f64>,
     +    holes: Option<Vec<PyReadonlyArray2<'py, f64>>>,
     +) -> PyResult<PyObject> {
          // body unchanged; use `exterior_coords.as_array()` etc.
      }
      @@
     -// around line 419
     -#[pyfunction]
     -pub fn path_length(
     -    path_coords: &PyReadonlyArray2<f64>,
     -) -> PyResult<f64> {
     +#[pyfunction]
     +pub fn path_length<'py>(
     +    _py: Python<'py>,
     +    path_coords: PyReadonlyArray2<'py, f64>,
     +) -> PyResult<f64> {
          // body unchanged
      }
      @@
     -// around line 476
     -#[pyfunction]
     -pub fn sample_along_path(
     -    positions: &PyReadonlyArray2<f64>,
     -) -> PyResult<Vec<f64>> {
     +#[pyfunction]
     +pub fn sample_along_path<'py>(
     +    _py: Python<'py>,
     +    positions: PyReadonlyArray2<'py, f64>,
     +) -> PyResult<Vec<f64>> {
          // body unchanged
      }
      @@
     -// around line 533..534
     -#[pyfunction]
     -pub fn graph_from_nodes_edges(
     -    nodes: &PyReadonlyArray2<f64>,
     -    edges: &PyReadonlyArray2<u32>,
     -) -> PyResult<Graph> {
     +#[pyfunction]
     +pub fn graph_from_nodes_edges<'py>(
     +    _py: Python<'py>,
     +    nodes: PyReadonlyArray2<'py, f64>,
     +    edges: PyReadonlyArray2<'py, u32>,
     +) -> PyResult<Graph> {
          // body unchanged
      }
      *** End Patch
      ]]>
    </file>

    <!-- 4) Optional: add brief doc hints to avoid misuse -->
    <file path="src/vector/api.rs" action="patch">
      <![CDATA[
      *** Begin Patch
      *** Update File: src/vector/api.rs
      @@
      /// NOTE: Numpy inputs must be 2D arrays shaped (N, 2). Parameters are accepted as
      /// `PyReadonlyArray2<'py, T>` (owned pyo3 handles). Do not use `&PyReadonlyArray2<T>`
      /// in #[pyfunction] signaturesâ€”pyo3 cannot extract references from Python call sites.
      *** End Patch
      ]]>
    </file>
  </changeset>

  <acceptance_criteria>
    <item>Project compiles successfully with <code>maturin develop --release</code> (no E0277 errors related to PyFunctionArgument / FromPyObject for numpy arrays).</item>
    <item>All #[pyfunction] parameters previously typed as <code>&PyReadonlyArray2&lt;T&gt;</code> are now <code>PyReadonlyArray2&lt;'py, T&gt;</code>.</item>
    <item>Any <code>Vec&lt;&amp;PyReadonlyArray2&lt;f64&gt;&gt;</code> is replaced with <code>Vec&lt;PyReadonlyArray2&lt;'py, f64&gt;&gt;</code>.</item>
    <item>Functions using these types declare a <code>'py</code> lifetime. If needed, an unused <code>_py: Python&lt;'py&gt;</code> parameter is added to satisfy lifetime constraints.</item>
    <item>Existing function bodies continue to operate via <code>.as_array()</code>/<code>.readonly()</code> without additional allocations.</item>
  </acceptance_criteria>

  <tests>
    <instruction>
      <![CDATA[
      1) Build locally:
         maturin develop --release

      2) Add a minimal smoke test (pytest) under tests/test_numpy_args.py:
      ---------------------------------------------------------
      import numpy as np
      import forge3d  # replace with actual module name

      def test_signatures_roundtrip():
          ext = np.array([[0.0, 0.0],[1.0, 0.0],[1.0, 1.0],[0.0, 1.0]], dtype=np.float64)
          holes = [np.array([[0.2,0.2],[0.8,0.2],[0.8,0.8],[0.2,0.8]], dtype=np.float64)]
          # functions below should reflect real exported names:
          if hasattr(forge3d, "build_polygon"):
              forge3d.build_polygon(ext, holes)

          path = np.stack([np.linspace(0,1,5), np.linspace(0,1,5)], axis=1).astype(np.float64)
          if hasattr(forge3d, "path_length"):
              forge3d.path_length(path)

          positions = path.astype(np.float64)
          if hasattr(forge3d, "sample_along_path"):
              forge3d.sample_along_path(positions)

          nodes = np.array([[0.0,0.0],[1.0,0.0],[1.0,1.0]], dtype=np.float64)
          edges = np.array([[0,1],[1,2]], dtype=np.uint32)
          if hasattr(forge3d, "graph_from_nodes_edges"):
              forge3d.graph_from_nodes_edges(nodes, edges)
      ---------------------------------------------------------

      3) Run: pytest -q
      ]]>
    </instruction>
  </tests>

  <risks>
    <item>If any function returns views or borrows tied to Python memory, ensure returned values don't outlive 'py; prefer copying to Rust-owned buffers before returning if necessary.</item>
    <item>Introducing <code>_py: Python&lt;'py&gt;</code> suppresses lifetime inference issues; keep the leading underscore to avoid unused warnings.</item>
  </risks>

  <roll_back_plan>
    <step>Revert only the signature changes if any downstream code requires references (it shouldnâ€™t for pyo3 extraction).</step>
    <step>Confirm numpy/pyo3 versions align with the ABI flags in pyproject.toml if builds still fail.</step>
  </roll_back_plan>
</task>
