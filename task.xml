<ClaudeCodeTask>
  <title>T1.2 – Height texture upload (R32Float) with 256-byte row alignment</title>
  <description>Implement ROADMAP item T1.2: upload a heightmap as an R32Float texture, handle cross-platform 256-byte row alignment, and expose a clean Python API. Keep public APIs stable and preserve build/test success.</description>

  <goals>
    <goal>Create GPU height texture (R32Float) with usages TEXTURE_BINDING | COPY_DST | COPY_SRC and a linear clamp sampler.</goal>
    <goal>Robustly upload arbitrary (W,H) float heightmaps with correct 256-byte row padding during transfer.</goal>
    <goal>Expose a Python method to perform the upload and add round-trip tests that read back texels to validate the upload.</goal>
  </goals>

  <constraints>
    <constraint>Do not regress any existing tests or builds (feature and non-feature builds).</constraint>
    <constraint>Follow current code style and error strings already used in the repo.</constraint>
    <constraint>All changes must be idempotent and minimal—touch only files listed below.</constraint>
  </constraints>

  <edits>
    <file path="src/lib.rs" action="modify">
      <instructions>
        Implement or harden <code>Renderer::upload_height_r32f(&mut self) -&gt; PyResult&lt;()&gt;</code> to:
        1) Require that <code>self.terrain</code> is present (same error message used elsewhere: "no terrain uploaded; call add_terrain() first").
        2) Create a <code>wgpu::Texture</code> with format <code>R32Float</code>, usages <code>TEXTURE_BINDING | COPY_DST | COPY_SRC</code>, and a clamp sampler (Nearest/Nearest/Nearest).
        3) Build a temporary padded upload buffer so <code>bytes_per_row</code> is aligned to <code>wgpu::COPY_BYTES_PER_ROW_ALIGNMENT</code> (256). Compute:
           - <code>row_bytes = width * 4</code>
           - <code>padded_bpr = ((row_bytes + 255) / 256) * 256</code>
           - Create <code>Vec&lt;u8&gt;</code> of size <code>padded_bpr * height</code> and copy each row from the input height slice (cast to bytes) into the padded buffer.
        4) Call <code>queue.write_texture</code> with <code>bytes_per_row: Some(NonZeroU32::new(padded_bpr).unwrap() [.into() if required by current wgpu type])</code> and <code>rows_per_image: Some(NonZeroU32::new(height).unwrap() [.into()])</code>.
        5) Store <code>self.height_tex</code>, <code>self.height_view</code>, <code>self.height_sampler</code>.
        6) If the method already exists, replace any non-aligned write path with the padded path described above.
        Keep the exact error strings already in use (e.g., for zero dims).
      </instructions>
      <hint>
        Prefer using the existing <code>self.terrain.heights: Vec&lt;f32&gt;</code>. Use <code>bytemuck::cast_slice&lt;f32, u8&gt;()</code> to form row views into the temporary padded buffer. Match the repo’s current pattern for <code>NonZeroU32</code> (some files use <code>.into()</code> to satisfy the type).
      </hint>
    </file>

```
<file path="src/lib.rs" action="modify">
  <instructions>
    Ensure the existing debug readback path (<code>debug_read_height_patch</code>) still uses padded reads from GPU to CPU, casts to <code>f32</code>, and returns a C-contiguous NumPy array. No API changes—only adjust if needed for compatibility.
  </instructions>
</file>

<file path="tests/test_height_upload.py" action="create">
  <instructions>
    Add tests that validate T1.2 behavior:
    1) <code>test_upload_height_roundtrip_various_sizes</code>: parameterize over sizes [(7,5), (64,48), (255,3), (33,33)] and generate a deterministic float32 heightmap. Use <code>Renderer.add_terrain()</code>, then <code>upload_height_r32f()</code>, then <code>read_full_height_texture()</code>. Assert shapes match and values are approximately equal (rtol=1e-6, atol=0).
    2) <code>test_upload_requires_terrain</code>: constructing Renderer then calling <code>upload_height_r32f()</code> without <code>add_terrain()</code> must raise with the exact message "no terrain uploaded; call add_terrain() first".
    3) <code>test_upload_handles_non_256_aligned_rows</code>: pick width such that width*4 % 256 != 0 (e.g., width=61), height=17; roundtrip equals input.
  </instructions>
  <template language="python"><![CDATA[
```

import numpy as np
import pytest
import vulkan\_forge as vf

def make\_height(h, w):
y, x = np.mgrid\[0\:h, 0\:w].astype(np.float32)
return (np.sin(x*0.13) + np.cos(y*0.17)).astype(np.float32)

@pytest.mark.parametrize("h,w", \[(5,7), (48,64), (3,255), (33,33), (17,61)])
def test\_upload\_height\_roundtrip\_various\_sizes(h, w):
r = vf.Renderer(w, h)
hm = make\_height(h, w)
r.add\_terrain(hm, spacing=(1.0,1.0), exaggeration=1.0, colormap="viridis")
r.upload\_height\_r32f()
out = r.read\_full\_height\_texture()
assert out.shape == hm.shape
assert out.dtype == np.float32
np.testing.assert\_allclose(out, hm, rtol=1e-6, atol=0.0)

def test\_upload\_requires\_terrain():
r = vf.Renderer(8, 8)
with pytest.raises(RuntimeError, match="no terrain uploaded; call add\_terrain\\(\\) first"):
r.upload\_height\_r32f()
]]></template> </file>

```
<file path="README.md" action="modify">
  <instructions>
    In the terrain section, add a short T1.2 note with a minimal code snippet showing <code>add_terrain()</code> → <code>upload_height_r32f()</code> → <code>read_full_height_texture()</code>. Mention R32Float, linear clamp sampler, and 256-byte row alignment handled internally.
  </instructions>
</file>
```

  </edits>

  <acceptance>
    <criterion>maturin develop --release builds on all platforms supported by the repo (same as current CI).</criterion>
    <criterion>pytest passes, including the new tests. Non-256-aligned widths do not trigger wgpu validation errors.</criterion>
    <criterion>Height texture is created as R32Float with usages TEXTURE_BINDING | COPY_DST | COPY_SRC and linear clamp sampler.</criterion>
    <criterion>Upload method stores texture/view/sampler on the Renderer and preserves existing public API and error messages.</criterion>
  </acceptance>

  <run>
    <commands>
      <cmd><![CDATA[
python -m pip install -U pip wheel maturin pytest numpy
maturin develop --release
pytest -q
]]></cmd>
    </commands>
  </run>

  <output>
    <format>unified-diff</format>
    <requirements>Print diffs for all touched files. Keep changes minimal.</requirements>
  </output>
</ClaudeCodeTask>
