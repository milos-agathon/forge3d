You are ChatGPT 5.1 Codex Max operating INSIDE a real repository checkout.

MISSION
Implement a deterministic “flake proofpack” for Milestones B, C, and D that:
- Produces ALL required PNGs + ALL required JSON metrics in the required output layout.
- NEVER handwaves missing artifacts/metrics. Missing/invalid/unreadable inputs are HARD FAILS.
- Still writes every required JSON + the global summary/manifest even on failure.
- Exits 0 ONLY if all selected milestone checks pass; otherwise exits non-zero.

NON-NEGOTIABLE BEHAVIOR
1) If any required artifact is missing/unreadable, you MUST:
   - still write `reports/flake/<ts>/meta/proofpack_summary.json` and `reports/flake/<ts>/meta/manifest.json`
   - write every required JSON file for requested sections (with pass=false + reasons)
   - include `missing_required: [...]` (paths relative to `reports/flake/<ts>/`)
   - exit non-zero
   - DO NOT say “cannot compute” without also emitting the required JSON containing failure details.

2) Determinism:
   - Use only standard Python + numpy + pillow (+ opencv-python ONLY if already in repo; do not introduce new deps).
   - No randomness unless explicitly seeded and recorded in the manifest.
   - Write JSON as UTF-8 with stable formatting: `indent=2`, `sort_keys=True`, newline at EOF.

3) No “creative interpretation”:
   - Implement the EXACT file layout and EXACT function signatures below.
   - Do not rename files, do not change signatures, do not omit outputs.
   - JSONs must include measured values (not just {"pass": false}). Missing keys is a FAIL.

4) JSON schema strictness:
   - Every metrics JSON MUST contain:
     - `pass` (bool)
     - `thresholds` (dict of threshold values)
     - `measured` (dict of measured values)
     - `notes` (list of strings; may be empty)
     - `missing_inputs` (list of strings; may be empty)
   - If a required input is missing, set `pass=false`, populate `missing_inputs`, and set measured fields to null where appropriate.

DELIVERABLES (CODE FILES YOU MUST CREATE/MODIFY)
- tools/run_flake_proofpack.py
- tools/proofpack_render.py
- tools/proofpack_analysis.py
- tools/proofpack_lib.py
- docs/debug_normal_contract.md

OUTPUTS
Write outputs to `reports/flake/<ts>/...` exactly as specified below and record sha256 + dimensions in manifest.

RESPONSE FORMAT (Codex Max)
- Provide unified diffs for each created/modified file.
- Provide a short “How to run” snippet:
  - `python tools/run_flake_proofpack.py --sections b,c,d`
- No marketing text. No “should”. No handwaving. No omissions.

========================================================
SPEC (VERBATIM — DO NOT EDIT OR PARAPHRASE)
You must implement exactly what is written below.
========================================================

# Milestone B — Diagnostic Modes are *Trusted Instruments*

## Goal
A screenshot must uniquely identify:
- water/branch selection issues (done already)
- **flake attribution**: specular vs height normals
- **LOD/blend encodings** are non-trivial and correct
- debug modes cannot silently fallback

## B.1 Required renders (perspective LOD-gradient scene)
**Scene**: `synthetic_perspective_lod_256`
- Must be perspective, with near and far regions in the same frame.
- Must include a sloped surface and curvature (so normals vary).
- Output: 256×256.

**Deliverables**
`reports/flake/<ts>/b/persp/`
- `mode0_baseline.png`
- `mode23_no_specular.png`
- `mode24_no_height_normal.png`
- `mode25_ddxddy_normal.png`
- `mode26_height_lod.png`
- `mode27_normal_blend.png`
- `debug_grid.png` (2×3 montage)

**Acceptance**
- All files exist and hashes recorded in manifest.

## B.2 Sentinel integrity (cannot be faked)
This is the missing piece that prevents “mode routing broken but CI still passes”.

**Deliverables**
`reports/flake/<ts>/b/sentinels/`
- `sentinel_mode23.png`
- `sentinel_mode24.png`
- `sentinel_mode25.png`
- `sentinel_mode26.png`
- `sentinel_mode27.png`
- `metrics_sentinel.json`

**Sentinel definitions (must be exact pixels)**
- mode23: solid red (255,0,0)
- mode24: solid green (0,255,0)
- mode25: solid blue (0,0,255)
- mode26: x ramp (0..255 left->right), grayscale in RGB
- mode27: y ramp (0..255 top->bottom), grayscale in RGB
alpha must be 255 everywhere for all sentinels.

**Acceptance**
`metrics_sentinel.json` must confirm:
- exact match ratios (>= 0.999)
- for ramps: correct orientation + `unique_bins_256 == 256`
- alpha all 255

## B.3 Non-uniformity of real Mode26/27 (actual LOD/blend)
We must prove the “real” debug outputs are not flat/constant.

**Deliverables**
`reports/flake/<ts>/b/persp/metrics_nonuniform.json`

**Metrics**
Compute for mode26 and mode27:
- luma mean, p05, p95
- `range = p95 - p05`
- `unique_bins_256` on luma (0..255)
- fail if alpha not 255 everywhere

**Acceptance**
- mode26: `range >= 0.20`, `unique_bins_256 >= 64`
- mode27: `range >= 0.15`, `unique_bins_256 >= 48`

## B.4 Attribution (HF energy must drop in the right ablations)
This confirms mode routing and flake contribution.

**Deliverables**
`reports/flake/<ts>/b/persp/metrics_attribution.json`

**Metrics**
Compute a simple “HF energy” metric from luma:
- convert to luma 0..1
- apply high-pass: luma - gaussian_blur(luma, sigma=1.0)
- hf_energy = mean(abs(hp))
Evaluate:
- baseline (mode0)
- no_specular (mode23)
- no_height_normal (mode24)

**Acceptance**
- hf_energy(mode23) <= 0.70 * hf_energy(mode0)
- hf_energy(mode24) <= 0.85 * hf_energy(mode0)
- hf_energy(mode23) < hf_energy(mode24)  (specular should be sharper)

## B.5 Mode distinctness (prevents “same image” bug)
**Deliverables**
`reports/flake/<ts>/b/persp/metrics_mode_distinctness.json`

**Metrics**
Compute SSIM approx (global, deterministic) and mean abs diff between:
- mode0 vs mode23
- mode0 vs mode24
- mode26 vs mode27

**Acceptance**
- All pairs must be “not identical”:
  - ssim <= 0.995 OR mean_abs_diff >= 0.002
- mode26 vs mode27 must be strongly different:
  - ssim <= 0.98 OR mean_abs_diff >= 0.01

**Milestone B Close Condition**
All: B1–B5 pass AND sentinels pass.

# Milestone C — Normal Ground Truth Comparison is Numerically Correct

## Goal
Prove the ddx/ddy normal path matches a ground-truth Sobel normal computation using the same height field.

## C.1 Canonical normal encoding contract (must exist)
**Deliverable**
- `docs/debug_normal_contract.md`

**Acceptance**
Must state:
- encoding from [-1,1] to [0,255] and back
- channel order
- whether alpha is used and how
- masking rules for invalid pixels

## C.2 Required renders
`reports/flake/<ts>/c/persp/`
- `mode25_ddxddy_normal.png`
- `modeXX_sobel_normal.png`
- `mode26_height_lod.png`
- `validity_mask_ref.png`
- `validity_mask_test.png`

## C.3 Mode25 non-degeneracy (your current blocker)
**Deliverable**
- `mode25_metrics.json`

**Metrics**
On luma of mode25:
- `valid_ratio` from validity_mask_test
- `alpha_mean` from mode25 alpha channel
- `luma_p95 - luma_p05`
- `unique_bins_256`

**Acceptance**
- `valid_ratio ≥ 0.99`
- `alpha_mean ≥ 0.99`
- `luma_p95 - luma_p05 ≥ 0.20`
- `unique_bins_256 ≥ 64`

## C.4 Angular error (the *core* gate)
**Deliverables**
- `normal_angle_error_summary.json`
- `normal_angle_error_heatmap.png`
- `normal_compare.png` (side-by-side ref/test, 512×256)

**Method**
Decode both normals to float3 in [-1,1], normalize.
Compute per-pixel angular error in degrees:
- angle = acos(clamp(dot(n_ref,n_test), -1, 1)) * 180/pi
Only include pixels valid in BOTH masks.

**Acceptance**
Report p50, p95, max for three depth bands (near/mid/far) based on mode26_height_lod:
- near: lod < 0.33
- mid: 0.33–0.66
- far: > 0.66

Thresholds:
- near: p95 ≤ 1.5°, max ≤ 5°
- mid:  p95 ≤ 2.5°, max ≤ 8°
- far:  p95 ≤ 4.0°, max ≤ 12°

## C.5 Diff visualization must be interpretable (no full saturation)
**Deliverables**
- `normal_diff_raw.json`
- `normal_diff_amplified.png`

**Method**
Compute raw angular errors (same as C.4).
Write raw stats json:
- overall p50,p95,max
- saturation_fraction if amplified image clips

Amplified image:
- map 0..5 deg to 0..255 (clip >5)
- grayscale png (RGB same)

**Acceptance**
- `raw_p95_deg ≤ 25` (sanity)
- `saturation_fraction ≤ 0.10`

**Milestone C Close Condition**
C1–C5 pass.

# Milestone D — Fade Eliminates Temporal Popping (With A/B)

## Goal
Demonstrate the LOD-based fade reduces temporal shimmer across an orbit **and** meets absolute stability thresholds.

## D.1 Blend curve verification
**Deliverables**
- `blend_curve_table.json`
- `blend_curve.png`

**Acceptance**
- monotonic non-increasing
- `blend(lod<=lod_lo)=1.0`
- `blend(lod>=lod_hi)=0.0`
- derivative endpoints near zero: `|dblend/dlod| ≤ 0.05` at lod_lo and lod_hi

## D.2 Orbit render packs (fade ON and OFF)
**Deliverables**
`reports/flake/<ts>/d/orbit_on/frame_0000.png ... frame_NNNN.png`
`reports/flake/<ts>/d/orbit_off/frame_0000.png ... frame_NNNN.png`

Also specular-only sequences (must exist):
`reports/flake/<ts>/d/orbit_on_spec/frame_*.png`
`reports/flake/<ts>/d/orbit_off_spec/frame_*.png`

**Acceptance**
- same frame count for on/off
- all frames decode, correct size, alpha 255

## D.3 Temporal metrics (by-frame + aggregate), luma and specular-only
**Deliverables**
- `temporal_metrics_by_frame.json`
- `temporal_metrics_synth.json` (aggregate)
- `compare_fade_on_off.json`

**Metrics**
Compute per-frame Δ = |L_t - L_{t-1}|.
Also compute same on “specular-only” render sequence (must exist; either debug mode or render pass):
- `orbit_on_spec/frame_*.png`
- `orbit_off_spec/frame_*.png`

**Absolute acceptance (strict)**
For fade ON:
- luma: `delta_mean ≤ 1.0`, `delta_p99 ≤ 10.0`, `delta_max ≤ 50.0`
- spec: `delta_mean ≤ 1.2`, `delta_p99 ≤ 14.0`, `delta_max ≤ 70.0`

**Relative acceptance**
Fade ON must improve vs OFF:
- `delta_mean_on ≤ 0.70 * delta_mean_off`
- `delta_p99_on ≤ 0.80 * delta_p99_off`

## D.4 Orbit integrity gate
**Deliverable**
- `orbit_integrity.json`

**Checks**
- frame-to-frame camera continuity (no jumps) using metadata or filename order
- no duplicate frames (hash comparison)
- no “flatline” (all-black or constant) segments

**Acceptance**
All checks pass.

**Milestone D Close Condition**
D1–D4 pass.

========================================================
REQUIRED FILE LAYOUT + FUNCTION SIGNATURES (VERBATIM)
========================================================

REQUIRED FILE LAYOUT (MUST MATCH EXACTLY)
=====================================================================

Create/modify these files:

1) tools/run_flake_proofpack.py
2) tools/proofpack_lib.py
3) tools/proofpack_analysis.py
4) tools/proofpack_render.py
5) docs/debug_normal_contract.md

Output layout (must match):

reports/flake/<ts>/
  meta/
    manifest.json
    proofpack_summary.json
  b/
    persp/
      mode0_baseline.png
      mode23_no_specular.png
      mode24_no_height_normal.png
      mode25_ddxddy_normal.png
      mode26_height_lod.png
      mode27_normal_blend.png
      debug_grid.png
      metrics_nonuniform.json
      metrics_attribution.json
      metrics_mode_distinctness.json
    sentinels/
      sentinel_mode23.png
      sentinel_mode24.png
      sentinel_mode25.png
      sentinel_mode26.png
      sentinel_mode27.png
      metrics_sentinel.json
  c/
    persp/
      mode25_ddxddy_normal.png
      modeXX_sobel_normal.png
      mode26_height_lod.png
      validity_mask_ref.png
      validity_mask_test.png
      mode25_metrics.json
      normal_angle_error_summary.json
      normal_angle_error_heatmap.png
      normal_compare.png
    diff/
      normal_diff_raw.json
      normal_diff_amplified.png
  d/
    blend/
      blend_curve_table.json
      blend_curve.png
    orbit_on/
      frame_0000.png
      ...
    orbit_off/
      frame_0000.png
      ...
    orbit_on_spec/
      frame_0000.png
      ...
    orbit_off_spec/
      frame_0000.png
      ...
    temporal/
      temporal_metrics_by_frame.json
      temporal_metrics_synth.json
      compare_fade_on_off.json
      orbit_integrity.json

FUNCTION SIGNATURES (DO NOT CHANGE)
=====================================================================

Create tools/proofpack_render.py with:

- def run_terrain_demo(
    *,
    python_exe: str,
    terrain_demo_path: str,
    dem_path: str | None,
    hdr_path: str | None,
    out_png: str,
    size: tuple[int, int],
    msaa: int,
    z_scale: float,
    albedo_mode: str,
    cam_phi: float,
    cam_theta: float,
    cam_radius: float,
    sun_azimuth: float,
    sun_intensity: float,
    gi: str,
    ibl_intensity: float,
    extra_args: list[str],
    env: dict[str, str],
) -> dict:
    """Shell out to terrain_demo.py. Must return a record containing:
       - cmd: list[str]
       - env: dict[str,str]
       - returncode: int
       - stdout: str (truncated)
       - stderr: str (truncated)
    """

- def ensure_dir(path: str) -> None

- def stamp_timestamp() -> str:
    """Return YYYYMMDD_HHMMSS in local time."""

Create tools/proofpack_analysis.py with:

- def load_png_rgba(path: str) -> "np.ndarray":
    """Return HxWx4 uint8. Raise on failure."""

- def luma_01(rgba_u8: "np.ndarray") -> "np.ndarray":
    """Return HxW float32 in [0,1] using Rec.709 coefficients."""

- def sha256_file(path: str) -> str

- def compute_nonuniform_metrics(luma_01: "np.ndarray") -> dict:
    """Return mean,p05,p95,unique_bins_256."""

- def ssim_approx(a: "np.ndarray", b: "np.ndarray") -> float:
    """Implement simple SSIM (global) in pure numpy. Deterministic."""

- def mean_abs_diff(a: "np.ndarray", b: "np.ndarray") -> float

- def decode_normal(rgb_u8: "np.ndarray") -> "np.ndarray":
    """Input HxWx3 uint8 -> float32 HxWx3 in [-1,1]."""

- def normalize_vec3(v: "np.ndarray", eps: float = 1e-8) -> "np.ndarray"

- def angle_error_deg(n_ref: "np.ndarray", n_test: "np.ndarray", valid: "np.ndarray") -> "np.ndarray":
    """Return float32 HxW degrees (0..180), invalid=nan."""

- def band_masks_from_lod(lod_01: "np.ndarray") -> dict[str, "np.ndarray"]:
    """Return boolean masks: near, mid, far."""

- def write_json(path: str, obj: dict) -> None:
    """Write indent=2, sort_keys=True, utf-8, newline."""

Create tools/proofpack_lib.py with:

- def collect_repo_state() -> dict:
    """Return git sha or dirty, python version, platform, package versions."""

- def record_png_manifest_entry(manifest: dict, logical_name: str, path: str) -> None:
    """Add sha256, width, height."""

Create tools/run_flake_proofpack.py with:

- def main(argv: list[str] | None = None) -> int

The CLI must accept:
- --sections b,c,d (comma list)
- --out reports/flake/<ts> (optional; if not provided auto timestamp)
- --python (optional)
- --terrain-demo (optional)

=====================================================================
IMPLEMENTATION GUIDANCE (NO WIGGLE ROOM)
=====================================================================

1) Rendering
- Use terrain_demo.py for rendering outputs. For synthetic scene, you may:
  - Use an internal mode in terrain_demo.py if exists, OR
  - Add a minimal “synthetic scene” flag to terrain_demo.py to render the required patterns.
- Sentinels can be generated directly (pure numpy + pillow) but must match exact pixels.

2) Analysis
- Every JSON listed in the required layout must be written.
- If a required input PNG is missing, write the JSON with pass=false and missing_inputs list; do not skip file creation.
- IMPORTANT: “pass:false only” JSON is forbidden. Every JSON MUST include thresholds + measured values (nulls allowed only if inputs missing).

3) Summary
- `meta/proofpack_summary.json` must include:
  - overall_pass boolean
  - per-section pass booleans and reasons
  - missing_required list
  - thresholds and measured values
  - paths to all artifacts

END SPEC (VERBATIM)
========================================================

WORKPLAN (MUST FOLLOW)
1) Inspect repo for terrain_demo.py path; implement `run_terrain_demo` to call it.
2) Implement `tools/run_flake_proofpack.py` as single entrypoint:
   - creates timestamped output dir unless --out provided
   - runs requested sections (b/c/d)
   - ALWAYS writes manifest + proofpack_summary
   - returns exit code (0 pass, 1 fail)
3) Implement render steps for B/C/D and analysis steps producing ALL required JSON.
4) Ensure every metrics JSON conforms to the strict schema (pass/thresholds/measured/notes/missing_inputs).
5) Make CI fail loudly and deterministically on any missing/invalid/miscomputed artifact.

END.
