<task id="ws-A1-pathtracer-gpu" version="1.0">
  <title>Implement A1: Compute Path Tracer MVP — GPU Kernel (WGSL) + Rust backend + Python bridge</title>

  <role>
    You are OpenAI Codex CLI operating as a senior graphics/runtime engineer.
    Stack: Vulkan ≥1.2 (design-compat), WebGPU/wgpu + WGSL, Rust, Python ≥3.8 (PyO3/maturin abi3), CMake ≥3.24, VMA, Sphinx.
    Project: forge3d — Rust backend + Python frontend for interactive/offline 3D visualization.
  </role>

  <switches>
    <WRITE_CHANGES>true</WRITE_CHANGES>
    <USE_TESTS>true</USE_TESTS>
    <ENSURE_CI>true</ENSURE_CI>
  </switches>

  <constraints>
    <platforms>win_amd64, linux_x86_64, macos_universal2</platforms>
    <gpuBudget>≤ 512 MiB host-visible heap</gpuBudget>
    <safety>
      - Make only the minimal changes needed for the A1 MVP.
      - Never delete custom user code; only add .gitignore entries for generated artifacts.
      - Keep commits small and scoped: one logical commit per subtask.
      - If a tool is missing, mark the step SKIPPED with the exact command to run.
    </safety>
    <exclusions>.git, dist, build, .venv, venv, node_modules, __pycache__, *.png, *.jpg, *.pdf, *.whl, *.zip, *.tar.gz, out, diag_out</exclusions>
  </constraints>

  <inputs>
    <repoRoot>./</repoRoot>
    <roadmapPath>./roadmap2.csv</roadmapPath>
    <workstreamSelector>
      <![CDATA[
      ID: A1
      Title: Compute Path Tracer MVP - GPU Kernel Implementation
      ]]>
    </workstreamSelector>
  </inputs>

  <acceptanceCriteria>
    <ac id="AC-1">roadmap2.csv contains a row with Workstream ID "A1" (case-insensitive) whose Title contains "Compute Path Tracer MVP". If not found → UNCERTAIN (list discovered workstreams), STOP.</ac>
    <ac id="AC-2">WGSL compute kernel exists at src/shaders/pt_kernel.wgsl with: (a) uniforms (width, height, frame_index), camera params, scene buffer; (b) xorshift64* RNG matching CPU sequence; (c) jittered primary rays; (d) ray–sphere intersections; (e) HDR accumulation and Reinhard tonemap; (f) documented bind groups/bindings in file header.</ac>
    <ac id="AC-3">Rust backend implements PathTracerGPU (src/path_tracing/mod.rs) with compute pipeline creation, bind group layout, buffers (uniforms/scene/accum/output), tiling dispatch, and GPU→CPU readback producing RGBA output.</ac>
    <ac id="AC-4">Python bridge (python/forge3d/path_tracing.py) uses GPU when available, falls back to CPU otherwise, preserves determinism with fixed seeds, and exposes render_rgba(width,height,scene,camera,seed,frames=1,use_gpu=True).</ac>
    <ac id="AC-5">Unit test tests/test_path_tracing_gpu.py verifies: (a) adapter detection + skip if none; (b) 64×64 single-sphere render runs on GPU; (c) deterministic RNG with fixed seed (first N samples match CPU to tolerance); (d) fallback to CPU if GPU disabled.</ac>
    <ac id="AC-6">Docs updated: brief section in README.md and docs/api (if Sphinx present) describing A1 GPU tracer usage and limitations.</ac>
    <ac id="AC-7">Code compiles/lints/tests on all platforms (fmt/clippy/pytest/docs/wheel OK). CI updated/ensured if missing.</ac>
  </acceptanceCriteria>

  <prechecks>
    <!-- Verify roadmap row exists -->
    <command>
      <![CDATA[
python - <<'PY'
import csv, sys, codecs
ws_id="A1".lower()
found=False
rows=[]
try:
  with codecs.open("roadmap2.csv","r","utf-8-sig") as f:
    rdr=csv.DictReader(f)
    for r in rdr:
      rows.append((r.get("Workstream ID",""), r.get("Workstream Title","")))
      if (r.get("Workstream ID","").lower()==ws_id) or ("compute path tracer mvp" in r.get("Workstream Title","").lower()):
        found=True
except FileNotFoundError:
  print("UNCERTAIN: roadmap2.csv not found", file=sys.stderr); sys.exit(2)
if not found:
  print("UNCERTAIN: A1 not found. Workstreams:", sorted(set(rows))[:50]); sys.exit(3)
print("WORKSTREAM_FOUND:A1")
PY
      ]]>
    </command>
  </prechecks>

  <design>
    <wgslBindings>
      <![CDATA[
# src/shaders/pt_kernel.wgsl — header doc (required)
Bind Group 0:
  @binding(0) uniform Uniforms {
    width: u32; height: u32; frame_index: u32; _pad: u32;
    cam_origin: vec3<f32>; cam_fov_y: f32;
    cam_right: vec3<f32>; cam_aspect: f32;
    cam_up: vec3<f32>;    cam_exposure: f32;
    cam_forward: vec3<f32>; seed_hi: u32; seed_lo: u32;
  };
Bind Group 1:
  @binding(0) readonly storage buffer Scene { spheres: array<Sphere>; };
  // MVP sphere only
  struct Sphere { center: vec3<f32>; radius: f32; albedo: vec3<f32>; _pad0: f32; }
Bind Group 2:
  @binding(0) storage buffer Accum { hdr: array<vec4<f32>>; }; // linear HDR accumulation
Bind Group 3:
  @binding(0) storage texture2D<rgba16float, write>; // tonemapped output
Workgroup: @workgroup_size(8,8,1)
RNG: xorshift64* emulated with vec2<u32> (hi,lo) to match CPU sequence (constant 0x2545F4914F6CDD1D).
Jitter: tent filter applied via two RNG calls, mapped to [-0.5,+0.5] pixels.
Tonemap: Reinhard: c/(1+c), then apply exposure; write to RGBA16F storage texture.
      ]]>
    </wgslBindings>
    <rustAPI>
      <![CDATA[
pub struct PathTracerGPU {
  device: Arc<wgpu::Device>,
  queue: Arc<wgpu::Queue>,
  pipeline: wgpu::ComputePipeline,
  bgl0: wgpu::BindGroupLayout, bgl1: wgpu::BindGroupLayout, bgl2: wgpu::BindGroupLayout, bgl3: wgpu::BindGroupLayout,
  uniforms: wgpu::Buffer,
  scene_buf: wgpu::Buffer,
  accum_buf: wgpu::Buffer,
  out_tex: wgpu::Texture, out_view: wgpu::TextureView,
  bind0: wgpu::BindGroup, bind1: wgpu::BindGroup, bind2: wgpu::BindGroup, bind3: wgpu::BindGroup,
  width: u32, height: u32, frame_index: u32,
}
impl PathTracerGPU {
  pub fn new(device:&Arc<wgpu::Device>, queue:&Arc<wgpu::Queue>, width:u32, height:u32, scene:&[SphereCPU], cam:&CameraCPU) -> anyhow::Result<Self> { /* create buffers/pipeline/binds */ }
  pub fn dispatch(&mut self, tiles:Option<(u32,u32)>) -> anyhow::Result<()> { /* encode compute pass, dispatch ceil_div(width,8) */ }
  pub fn read_rgba(&self) -> anyhow::Result<Vec<u8>> { /* copy out_tex -> buffer -> map -> RGBA8 via conversion */ }
}
      ]]>
    </rustAPI>
    <pythonAPI>
      <![CDATA[
# python/forge3d/path_tracing.py
class PathTracer:
    def render_rgba(self, width:int, height:int, scene, camera, seed:int=1, frames:int=1, use_gpu:bool=True) -> "np.ndarray[H,W,4] uint8":
        """
        Uses GPU if available and allowed; falls back to CPU implementation.
        Deterministic for fixed seed + frames=1. For frames>1, progressive accumulation with fixed per-frame seeds.
        """
      ]]>
    </pythonAPI>
  </design>

  <changes>
    <createOrModify>
      <file path="src/path_tracing/mod.rs" kind="new"/>
      <file path="src/path_tracing/compute.rs" kind="new"/>
      <file path="src/shaders/pt_kernel.wgsl" kind="modify-or-new"/>
      <file path="python/forge3d/path_tracing.py" kind="modify"/>
      <file path="tests/test_path_tracing_gpu.py" kind="new"/>
      <file path=".gitignore" kind="modify-append"/>
      <file path="README.md" kind="modify-append"/>
      <file path="docs/api/path_tracing.md" kind="new-optional"/>
    </createOrModify>

    <implNotes>
      <![CDATA[
- WGSL: Implement xorshift64* with vec2<u32> (hi,lo):
    fn rotl64(x: vec2<u32>, n:u32) -> vec2<u32> { /* 64-bit rotate via (hi,lo) */ }
    fn shl64(x: vec2<u32>, n:u32) -> vec2<u32> { /* 64-bit shift */ }
    fn shr64(x: vec2<u32>, n:u32) -> vec2<u32> { /* 64-bit shift */ }
    fn mul64(a: vec2<u32>, b: vec2<u32>) -> vec2<u32> { /* 128-bit -> low64 using u32 math */ }
    const C: vec2<u32> = vec2<u32>(0x4F6CDD1D, 0x2545F491); // lo, hi of 0x2545F4914F6CDD1D
    // x ^= x >> 12; x ^= x << 25; x ^= x >> 27; x * C;
- Scene MVP: array<Sphere>; compute nearest hit and simple lambert shading with constant light dir or white albedo.
- Accumulation: hdr[idx] = mix(hdr[idx], sample, 1.0 / f32(frame_index+1u)); then reinhard + exposure, write to out texture.
- Rust: ensure bind group layouts reflect WGSL; use storage texture format rgba16float for out.
- Tiling: default tile 256×256 if width*height large; loop dispatch over tiles; keep memory usage ≤512 MiB host-visible.
- Readback: copy texture to a temp RGBA16F buffer, map, convert to u8 RGBA in Rust (or do a tonemap/output-to-RGBA8 in kernel).
- Determinism: base RNG seed on (seed ^ frame_index) and per-pixel hashed coords (e.g., Wang hash) but keep sequence identical to CPU baseline for first draw; validate with tests.
      ]]>
    </implNotes>
  </changes>

  <tests>
    <python path="tests/test_path_tracing_gpu.py">
      <![CDATA[
import os, pytest, numpy as np
from forge3d.path_tracing import PathTracer, make_sphere, make_camera

def _gpu_available():
    try:
        # import internal probe if exists; else attempt to construct tracer
        return True
    except Exception:
        return False

@pytest.mark.skipif(not _gpu_available(), reason="No compatible GPU adapter")
def test_gpu_single_sphere_64x64_deterministic(tmp_path):
    tracer = PathTracer()
    scene = [make_sphere(center=(0,0,-3), radius=1.0, albedo=(0.8,0.2,0.2))]
    cam   = make_camera(origin=(0,0,0), look_at=(0,0,-1), up=(0,1,0), fov_y=45.0, aspect=1.0, exposure=1.0)
    img1 = tracer.render_rgba(64,64,scene,cam,seed=123,frames=1,use_gpu=True)
    img2 = tracer.render_rgba(64,64,scene,cam,seed=123,frames=1,use_gpu=True)
    assert img1.shape == (64,64,4)
    assert np.all(img1 == img2), "deterministic for 1 frame with fixed seed"

def test_fallback_cpu(tmp_path):
    tracer = PathTracer()
    scene = [make_sphere(center=(0,0,-3), radius=1.0, albedo=(1,1,1))]
    cam   = make_camera(origin=(0,0,0), look_at=(0,0,-1), up=(0,1,0), fov_y=45.0, aspect=1.0, exposure=1.0)
    img = tracer.render_rgba(32,32,scene,cam,seed=1,frames=1,use_gpu=False)
    assert img.shape == (32,32,4)
      ]]>
    </python>
  </tests>

  <plan>
    <!-- EXACTLY INCLUDE THESE STEPS -->
    5) Implementation (Write mode only if &lt;WRITE_CHANGES&gt;true&lt;/WRITE_CHANGES&gt;)
       - Create branch: <code>git checkout -b ws-&lt;ID-or-slug&gt;-implementation</code>
       - For each task in deterministic order (by Priority then Task ID):
         * Apply minimal changes.
         * Add/update tests when <USE_TESTS>true</USE_TESTS>.
         * Update docs (Sphinx/README) and example scripts if referenced by AC.
         * Update CI if <ENSURE_CI>true</ENSURE_CI> and AC requires.
         * Keep one commit per task: <code>git commit -am "WS&lt;ID&gt; &lt;TaskID&gt;: &lt;short summary&gt;"</code>
       - Maintain safety: never delete custom user code; only remove generated artifacts (.pyd/.so, build/ etc.) when explicitly required by AC; otherwise add .gitignore entries.

    6) Validation Run
       - Commands (skip gracefully if tool missing; record SKIPPED):
         * <code>cargo fmt -- --check</code>
         * <code>cargo clippy --all-targets --all-features -D warnings</code>
         * <code>cargo test -q</code>
         * <code>pytest -q</code> (when <USE_TESTS>true</USE_TESTS>)
         * <code>sphinx-build -b html docs _build/html</code>
         * <code>maturin build --release</code>
         * <code>cmake -S . -B build && cmake --build build</code> (if CMake wrapper is part of AC)
       - Re-run the audit matrix; all tasks should now be <b>Present & Wired</b>.
       - If any still failing → fix or mark explicitly BLOCKED with reason.

    7) PR Preparation
       - Generate <b>PR_BODY.md</b> summarizing: scope, tasks addressed, evidence, risks/mitigations, and validation output.
       - Print final change summary: <code>git status -s</code>, <code>git log --oneline -n 50</code>.
  </plan>

  <execution>
    <steps>
      <step>Create feature branch: <code>git checkout -b ws-A1-implementation</code></step>
      <step>Expand/create <code>src/shaders/pt_kernel.wgsl</code> with the documented header, uniforms, scene, RNG (xorshift64*), jittered primary rays, ray–sphere hit, HDR accumulation, Reinhard tonemap, and storage texture write.</step>
      <step>Add Rust backend files: <code>src/path_tracing/mod.rs</code>, <code>src/path_tracing/compute.rs</code> implementing <code>PathTracerGPU</code>, pipeline creation, buffers, bind groups, tiling dispatch, and readback.</step>
      <step>Modify Python bridge: <code>python/forge3d/path_tracing.py</code> to expose <code>render_rgba(..., use_gpu=True)</code>, with GPU detection/selection and deterministic seeding; fallback to CPU path if GPU unavailable.</step>
      <step>Create tests: <code>tests/test_path_tracing_gpu.py</code> per above; mark GPU dependency with a skip guard.</step>
      <step>Append <code>.gitignore</code> with <code>out/</code>, <code>diag_out/</code>, build artifacts as needed; keep user code untouched.</step>
      <step>Docs: add a short usage section to <code>README.md</code>; if docs/ exists, add <code>docs/api/path_tracing.md</code> and link from index.</step>
      <step>Run Validation Run commands; fix non-flaky failures. Record any SKIPPED with the command to run locally.</step>
      <step>Generate <code>PR_BODY.md</code> summarizing changes and results. Print <code>git status -s</code> and <code>git log --oneline -n 50</code>.</step>
    </steps>
  </execution>

  <completion>
    <print>
      - src/shaders/pt_kernel.wgsl (expanded)
      - src/path_tracing/mod.rs
      - src/path_tracing/compute.rs
      - python/forge3d/path_tracing.py
      - tests/test_path_tracing_gpu.py
      - README.md (updated)
      - docs/api/path_tracing.md (if Sphinx present)
      - PR_BODY.md
    </print>
    <fallback>
      If A1 is not found in roadmap2.csv, respond <b>UNCERTAIN</b> with discovered workstreams (ID→Title) and STOP without changes.
    </fallback>
  </completion>
</task>
