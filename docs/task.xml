<task>
  <title>Implement & wire missing/partial items for Workstream W</title>

  <inputs>
    <repoRoot>./</repoRoot>
    <paths>
      <path>src/</path>
      <path>shaders/</path>
      <path>python/forge3d/</path>
      <path>examples/</path>
      <path>notebooks/integration/</path>
      <path>tests/</path>
      <path>tests/goldens/</path>
      <path>docs/</path>
      <path>.github/workflows/</path>
    </paths>
    <workstream id="W" title="Integration Docs &amp; CI">
      <item id="W1" title="End-to-end notebooks for Python stack"/>
      <item id="W2" title="CI validation for I/O and CRS correctness"/>
      <item id="W3" title="Features &amp; limits gating at device request (fallback matrices)"/>
      <item id="W4" title="GPU timestamp &amp; pipeline statistics queries (with fallback)"/>
      <item id="W5" title="Copy/layout/usage conformance (buffers &amp; textures)"/>
      <item id="W6" title="Sampler vs texture sampleType compatibility tests + fallbacks"/>
      <item id="W7" title="Buffer mapping lifecycle correctness &amp; negative tests"/>
      <item id="W8" title="External image import demo (copyExternalImageToTexture parity)"/>
    </workstream>
  </inputs>

  <constraints>
    <platforms>win_amd64, linux_x86_64, macos_universal2</platforms>
    <gpuBudget>&#8804; 512 MiB host-visible heap</gpuBudget>
    <build>cmake≥3.24, cargo/rustc, PyO3, VMA</build>
    <apis>Primary: WebGPU/WGSL; Vulkan 1.2-compatible design</apis>
    <docs>Sphinx</docs>
    <scope>Only Workstream W; do not modify other workstreams</scope>
  </constraints>

  <safety>
    <step>Create branch: <code>git checkout -b feat/workstream-w-integration-ci</code></step>
    <step>Audit-first: only add/modify files within declared paths; no blind search/replace; small, reviewable commits.</step>
    <step>Guard optional deps (e.g., Jupyter, PIL) behind availability checks; skip tests cleanly when unavailable.</step>
    <step>Exclude binary/artifact directories from commits.</step>
  </safety>

  <plan>
    <!-- Preflight & dependency awareness (non-blocking) -->
    <step id="P0">Preflight
      <item>Verify existing CI and test scaffolding; list files that will be added under <code>notebooks/integration/</code>, <code>tests/</code>, <code>.github/workflows/</code>, <code>docs/</code>.</item>
      <item>Confirm device caps/timing features present (W3/W4) but do not modify them.</item>
    </step>

    <!-- W1: Notebooks & CI execution -->
    <step id="W1-1">Create end-to-end notebooks
      <item>Add <code>notebooks/integration/matplotlib_terrain.ipynb</code> (terrain via mpl colormaps).</item>
      <item>Add <code>notebooks/integration/datashader_points.ipynb</code> (large-scale points → RGBA overlay).</item>
      <item>Add <code>notebooks/integration/adapter_showcase.ipynb</code> (adapters interop).</item>
      <item>Add <code>notebooks/integration/data_ingestion.ipynb</code> (I/O pipelines &amp; CRS checks).</item>
    </step>
    <step id="W1-2">Headless execution in CI
      <item>Add <code>.github/workflows/notebooks.yml</code> to run nbconvert headless on linux_x86_64 within a 10-minute budget per notebook.</item>
      <item>Store rendered PNG/HTML as CI artifacts under <code>artifacts/notebooks/</code>.</item>
    </step>

    <!-- W5: Copy/layout/usage conformance -->
    <step id="W5-1">Conformance tests (buffers &amp; textures)
      <item>Create <code>tests/test_copy_conformance.py</code> with positive/negative cases (COPY_SRC/DST flags, 256B alignment, depth-stencil coverage where supported).</item>
      <item>Validate scoped error messages for invalid operations.</item>
    </step>

    <!-- W6: Sampler/sampleType compatibility -->
    <step id="W6-1">Compatibility validation
      <item>Add explicit sampleType compatibility checks during sampler/texture binding.</item>
      <item>Create <code>tests/test_sampler_compat.py</code> with a compatibility matrix and illegal-combo rejection tests; include device-filtered fallbacks.</item>
    </step>

    <!-- W7: Buffer mapping lifecycle -->
    <step id="W7-1">Lifecycle &amp; negative tests
      <item>Add <code>tests/test_buffer_mapping.py</code> covering mapAsync state transitions, bounds validation, unmapped-usage errors, and basic race/misuse scenarios.</item>
    </step>

    <!-- W8: External image import parity -->
    <step id="W8-1">External image import (native copyExternalImageToTexture parity)
      <item>Add <code>src/external_image/mod.rs</code> (decode &amp; upload path for PNG/JPEG; parity constraints documented).</item>
      <item>Add <code>examples/external_image_demo.py</code> that loads an external image and uploads to a texture; renders a proof PNG.</item>
      <item>Add <code>docs/integration/external_images.md</code> describing native vs browser behavior, constraints, and pitfalls.</item>
      <item>Add tests under <code>tests/test_external_image.py</code> for decode/upload sanity (skipped on missing PIL).</item>
    </step>

    <!-- Docs -->
    <step id="DOCS">Documentation wiring
      <item>Ensure Sphinx TOC links to <code>docs/integration/external_images.md</code> and a short “Running notebooks in CI” section.</item>
    </step>

    <!-- Finalization -->
    <step id="FINAL">Validate &amp; PR
      <item>Run: <code>pytest -k "(copy_conformance or sampler_compat or buffer_mapping or external_image)" -v</code></item>
      <item>Execute notebooks locally (optional): <code>jupyter nbconvert --execute --to notebook notebooks/integration/*.ipynb</code></item>
      <item>Build docs: <code>cd docs &amp;&amp; make html</code></item>
      <item>Open PR with summary, runtime table per notebook, and test results.</item>
    </step>
  </plan>

  <deliverables>
    <!-- W1 -->
    <item>notebooks/integration/matplotlib_terrain.ipynb</item>
    <item>notebooks/integration/datashader_points.ipynb</item>
    <item>notebooks/integration/adapter_showcase.ipynb</item>
    <item>notebooks/integration/data_ingestion.ipynb</item>
    <item>.github/workflows/notebooks.yml</item>

    <!-- W5 -->
    <item>tests/test_copy_conformance.py</item>

    <!-- W6 -->
    <item>tests/test_sampler_compat.py</item>

    <!-- W7 -->
    <item>tests/test_buffer_mapping.py</item>

    <!-- W8 -->
    <item>src/external_image/mod.rs</item>
    <item>examples/external_image_demo.py</item>
    <item>tests/test_external_image.py</item>
    <item>docs/integration/external_images.md</item>
  </deliverables>

  <acceptanceCriteria>
    <!-- W1 -->
    <item>Each notebook executes headless via CI (nbconvert) within ≤10 minutes per notebook on linux_x86_64; exit code 0; artifacts uploaded under <code>artifacts/notebooks/</code>.</item>
    <item>Rendered outputs contain at least one PNG per notebook proving successful rendering path.</item>

    <!-- W5 -->
    <item>Conformance suite passes: valid COPY_SRC/DST, 256B alignment respected, depth-stencil copy behavior validated or explicitly skipped with rationale; negative tests assert expected error messages.</item>

    <!-- W6 -->
    <item>Sampler/texture sampleType compatibility enforced: illegal combinations are rejected with clear errors; tests cover at least 6 valid and 6 invalid matrix cases; device-filtered fallbacks verified.</item>

    <!-- W7 -->
    <item>Buffer mapping lifecycle tests pass: mapAsync state transitions correct; out-of-bounds ranges raise errors; unmapped usage errors caught; basic race/misuse scenarios handled deterministically.</item>

    <!-- W8 -->
    <item>External image demo runs and writes a proof image (<code>examples/output/external_image_demo.png</code>); texture content checksum is stable (SSIM ≥ 0.99 vs golden on reference runner).</item>
    <item>Native parity constraints documented; functionally equivalent upload path available via <code>external_image</code> module.</item>

    <!-- Global -->
    <item>All tests pass on CI (linux_x86_64 required; win_amd64/macos_universal2 unit suites green when enabled); peak RSS during tests ≤512 MiB.</item>
    <item>Sphinx builds cleanly; new docs are linked in TOC; zero warnings promoted to failure.</item>
  </acceptanceCriteria>

  <completion>
    <summary>Completes Workstream W by adding integration notebooks + CI execution, GPU conformance/compatibility/mapping tests, and an external image import parity path with demo and docs, all within memory and platform constraints.</summary>
    <commands>
      <cmd>pip install -e .[dev]</cmd>
      <cmd>maturin develop --release</cmd>
      <cmd>pytest -k "copy_conformance or sampler_compat or buffer_mapping or external_image" -v</cmd>
      <cmd>jupyter nbconvert --execute --to notebook notebooks/integration/*.ipynb</cmd>
      <cmd>cd docs &amp;&amp; make html</cmd>
    </commands>
  </completion>
</task>
