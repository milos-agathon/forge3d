<task id="forge3d-workstream-verify-and-implement" version="2.0">
  <title>Verify a workstream exists, audit readiness, and implement missing items in one branch/PR</title>

  <role>
    You are Codex CLI in <b>Verification → Implementation Mode</b>, acting as a senior graphics/runtime engineer
    (Vulkan ≥1.2, WebGPU/WGSL, RAII, Rust, Python ≥3.8, PyO3, CMake ≥3.24, VMA, Sphinx).
    Project: forge3d — Rust backend + Python frontend for interactive/offline 3D visualization.
  </role>

  <switches>
    <!-- Set WRITE_CHANGES=false to do verification only -->
    <WRITE_CHANGES>true</WRITE_CHANGES>
    <!-- When true, generate and run tests where feasible -->
    <USE_TESTS>true</USE_TESTS>
    <!-- When true, add/adjust CI to run fmt/clippy/pytest/docs/wheel (no publish) -->
    <ENSURE_CI>true</ENSURE_CI>
  </switches>

  <constraints>
    <platforms>win_amd64, linux_x86_64, macos_universal2</platforms>
    <gpuBudget>≤ 512 MiB host-visible heap</gpuBudget>
    <build>cargo/rustc, maturin abi3 (py≥3.8), optional CMake≥3.24 wrapper</build>
    <apis>WebGPU/WGSL primary; Vulkan 1.2-compatible design</apis>
    <docs>Sphinx preferred; README/CHANGELOG kept accurate</docs>
    <safety>
      - Work in a feature branch. Keep commits small and scoped to a single task.
      - Prefer minimal edits; do not remove user content unless obviously generated artifacts.
      - If an operation would delete or overwrite code, create a backup copy first.
      - If essential information is missing, reply <b>UNCERTAIN</b> and list exact needs.
      - If a tool is unavailable, mark the check as SKIPPED with the command to run.
    </safety>
    <exclusions>.git, dist, build, .venv, venv, node_modules, __pycache__, *.png, *.jpg, *.pdf, *.whl, *.zip, *.tar.gz, out, diag_out</exclusions>
  </constraints>

  <inputs>
    <repoRoot>./</repoRoot>
    <roadmapPath>./roadmap2.csv</roadmapPath>
    <workstreamSelector>
      <![CDATA[
      ID: A
      Title: Path Tracing (WebGPU Compute, Offline HQ)
      ]]>
  </inputs>

  <csvSchema>
    <encoding>utf-8</encoding>
    <delimiter>comma</delimiter>
    <columns order="fixed">
      <col index="0">Workstream ID</col>
      <col index="1">Workstream Title</col>
      <col index="2">Task ID</col>
      <col index="3">Task Title</col>
      <col index="4">Rationale</col>
      <col index="5">Deliverables</col>
      <col index="6">Acceptance Criteria</col>
      <col index="7">Priority</col>
      <col index="8">Phase</col>
      <col index="9">Missing Features</col>
      <col index="10">Dependencies</col>
      <col index="11">Risks/Mitigations</col>
      <col index="12" optional="true" ignore="true">Unnamed: 12</col>
    </columns>
    <cellConventions>
      <listSeparator>semicolon-inside-cell</listSeparator>
      <markdownInline>allowed</markdownInline>
      <emptyTrailingColumn>ignore if entirely blank</emptyTrailingColumn>
    </cellConventions>
  </csvSchema>

  <plan>
    1) Validate & Load CSV
       - Read <roadmapPath> with UTF-8; verify headers match <csvSchema>.
       - If headers differ → <b>UNCERTAIN</b> with a diff table and stop.
       - Produce CSV Hygiene: rows with out-of-vocab Priority/Phase; rows missing Task ID/Title/Deliverables/Acceptance Criteria.

    2) Select Workstream (Existence Check)
       - Case-insensitive match by Workstream ID OR Title.
       - If none match → <b>UNCERTAIN</b> and list discovered workstreams (ID → Title), then stop.
       - If matched, print “WORKSTREAM_FOUND” with count of tasks.

    3) Derive Task Intents
       - For each matched task (respecting priority/phase filters), parse Deliverables & Acceptance Criteria into concrete artifacts:
         * probable file paths (e.g., src/shaders/*.wgsl, python/forge3d/*.py, docs/*, examples/*)
         * symbols/APIs (create_render_pipeline, bind_group, class/func names)
         * tests/docs/CI hooks
       - Build a per-task keyword set from cell contents (split semicolons inside cells).

    4) Repository Audit (Read-only)
       - For each task, scan src/, shaders/, python/, examples/, docs/ with ripgrep.
       - Classify readiness:
         <b>Present & Wired</b> (artifacts exist + integrated)
         <b>Present but Partial</b> (exists but missing wiring/tests/docs)
         <b>Absent</b> (no meaningful artifacts)
       - Capture evidence: file:line refs + brief snippet.

    5) Minimal Change Plan (Per Task)
       - For Partial/Absent, list the exact minimal file-level changes needed to meet Acceptance Criteria and constraints (platforms/build/GPU budget).
       - If unclear → mark the task <b>BLOCKED</b> and specify exactly what artifact/decision is needed.

    6) Implementation (Write mode only if <WRITE_CHANGES>true</WRITE_CHANGES>)
       - Create branch: <code>git checkout -b ws-&lt;ID-or-slug&gt;-implementation</code>
       - For each task in deterministic order (by Priority then Task ID):
         * Apply minimal changes.
         * Add/update tests when <USE_TESTS>true</USE_TESTS>.
         * Update docs (Sphinx/README) and example scripts if referenced by AC.
         * Update CI if <ENSURE_CI>true</ENSURE_CI> and AC requires.
         * Keep one commit per task: <code>git commit -am "WS&lt;ID&gt; &lt;TaskID&gt;: &lt;short summary&gt;"</code>
       - Maintain safety: never delete custom user code; only remove generated artifacts (.pyd/.so, build/ etc.) when explicitly required by AC; otherwise add .gitignore entries.

    7) Validation Run
       - Commands (skip gracefully if tool missing; record SKIPPED):
         * <code>cargo fmt -- --check</code>
         * <code>cargo clippy --all-targets --all-features -D warnings</code>
         * <code>cargo test -q</code>
         * <code>pytest -q</code> (when <USE_TESTS>true</USE_TESTS>)
         * <code>sphinx-build -b html docs _build/html</code>
         * <code>maturin build --release</code>
         * <code>cmake -S . -B build && cmake --build build</code> (if CMake wrapper is part of AC)
       - Re-run the audit matrix; all tasks should now be <b>Present & Wired</b>.
       - If any still failing → fix or mark explicitly BLOCKED with reason.

    8) PR Preparation
       - Generate <b>PR_BODY.md</b> summarizing: scope, tasks addressed, evidence, risks/mitigations, and validation output.
       - Print final change summary: <code>git status -s</code>, <code>git log --oneline -n 50</code>.

  </plan>

  <deliverables>
    <!-- Always produced -->
    <file>reports/ws_audit.md</file>
    <file>reports/ws_matrix.csv</file>
    <file>reports/csv_hygiene.md</file>
    <!-- Produced in write mode -->
    <file optional="true">PR_BODY.md</file>
    <file optional="true">PATCHPLAN.md</file>
  </deliverables>

  <acceptanceCriteria>
    <ac id="AC-001">Workstream existence is verified; if not found, returns <b>UNCERTAIN</b> listing available IDs/Titles.</ac>
    <ac id="AC-002">Each selected task has a single readiness verdict with at least one evidence reference or “no evidence found”.</ac>
    <ac id="AC-003">For every Partial/Absent task, a concrete minimal change list exists (paths/symbols).</ac>
    <ac id="AC-004" when="WRITE_CHANGES=true">All feasible tasks are implemented with one commit per task on a feature branch.</ac>
    <ac id="AC-005" when="WRITE_CHANGES=true">Validation run completes; failures are either fixed or explicitly BLOCKED with reasons and next steps.</ac>
    <ac id="AC-006">Deliverables (reports and, if applicable, PR docs) are generated and printed.</ac>
  </acceptanceCriteria>

  <execution>
    <commands>
      <!-- CSV header check -->
      - python - <<'PY'
import csv, sys, codecs, os
p = os.environ.get("ROADMAP","{{roadmapPath}}")
try:
    with codecs.open(p, "r", "utf-8-sig") as f:
        rdr = csv.reader(f); hdr = next(rdr, [])
    print("CSV_HEADERS_OK" if hdr[:13]==[
        "Workstream ID","Workstream Title","Task ID","Task Title","Rationale",
        "Deliverables","Acceptance Criteria","Priority","Phase","Missing Features",
        "Dependencies","Risks/Mitigations","Unnamed: 12"
    ] else "CSV_HEADERS_DIFF", hdr)
except FileNotFoundError:
    print("UNCERTAIN: roadmap.csv not found at", p); sys.exit(2)
PY

      <!-- Discover candidate workstreams -->
      - python - <<'PY'
import csv, codecs
with codecs.open("{{roadmapPath}}","r","utf-8-sig") as f:
    rdr = csv.DictReader(f)
    ws = sorted({(r["Workstream ID"].strip(), r["Workstream Title"].strip()) for r in rdr})
print("WORKSTREAMS:", ws[:50])
PY

      <!-- Ripgrep presence scan (read-only audit) -->
      - rg --version
      - rg -n --hidden -g '!.git' -g '!dist' -g '!build' -g '!.venv' -g '!venv' -g '!node_modules' -g '!__pycache__' \
        '(wgsl|@group\\(|@binding\\(|bind_group|create_render_pipeline|queue\\.write_(buffer|texture)|forge3d|from +forge3d +import|sphinx|maturin|CMakeLists\\.txt)' \
        src/ shaders/ python/ examples/ docs/ || true

      <!-- Optional: quick env snapshot -->
      - rustc --version || true
      - cargo --version || true
      - python -V || true
      - cmake --version || true
      - sphinx-build --version || true
      - maturin --version || true
    </commands>

    <notes>
      - Build per-task keyword sets from Deliverables/Acceptance Criteria/Dependencies; split semicolons inside those cells only.
      - Use conservative defaults for platform-specific paths (Windows DLL search, macOS rpaths, Linux SONAME).
      - Respect the ≤512 MiB host-visible budget when adding examples/buffers; prefer small fixtures.
    </notes>
  </execution>

  <implementation when="WRITE_CHANGES=true">
    <steps>
      <step>git checkout -b ws-&lt;slug-from-ID-or-Title&gt;-implementation</step>
      <step>For each <b>Partial/Absent</b> task:
        <ul>
          <li>Apply minimal code/doc/test edits per the task’s Acceptance Criteria.</li>
          <li>If a required artifact is ambiguous, create a thin, documented placeholder and mark the exact TODO in code + reports.</li>
          <li>Update or add tests when <USE_TESTS>true</USE_TESTS>; prefer deterministic image/array checks where applicable.</li>
          <li>Update Sphinx/README/CHANGELOG when docs are part of AC.</li>
          <li>Commit: <code>git commit -am "WS&lt;ID&gt; &lt;TaskID&gt;: &lt;concise change&gt;"</code></li>
        </ul>
      </step>
      <step when="ENSURE_CI=true">If CI workflow missing, add <code>.github/workflows/ci.yml</code> to run fmt/clippy/pytest/docs/wheel on linux/macos/windows (no publish).</step>
      <step>Run validation commands; fix non-flaky failures; otherwise mark BLOCKED with reason and a single command the maintainer should run to unblock.</step>
      <step>Generate <b>PR_BODY.md</b> summarizing changes, risks, mitigations, and validation outputs; print <code>git status -s</code> and <code>git log --oneline -n 50</code>.</step>
    </steps>
  </implementation>

  <completion>
    <print>
      - reports/ws_audit.md
      - reports/ws_matrix.csv
      - reports/csv_hygiene.md
      - PR_BODY.md (if WRITE_CHANGES=true)
      - PATCHPLAN.md (if WRITE_CHANGES=true)
    </print>
    <fallback>
      If headers mismatch or workstream not found, stop with <b>UNCERTAIN</b> and list:
      (a) expected vs actual headers, (b) discovered workstreams (ID → Title), and (c) exact fixes required.
    </fallback>
  </completion>
</task>
