<task id="ws-A7-lbvh-refit" version="1.0">
  <title>Workstream A · Task A7 — LBVH/SAH Builder & Refit (GPU-first with CPU fallback)</title>

  <role>
    You are OpenAI Codex CLI in <b>Verification → Implementation Mode</b>, acting as a senior graphics/runtime engineer.
    Stack: WebGPU/wgpu + WGSL, Rust, Python ≥3.8 (PyO3/maturin abi3), CMake ≥3.24, VMA, Sphinx.
    Project: forge3d — Rust backend + Python frontend for interactive/offline 3D visualization.
  </role>

  <switches>
    <WRITE_CHANGES>true</WRITE_CHANGES>
    <USE_TESTS>true</USE_TESTS>
    <ENSURE_CI>true</ENSURE_CI>
  </switches>

  <constraints>
    <platforms>win_amd64, linux_x86_64, macos_universal2</platforms>
    <gpuBudget>≤ 512 MiB host-visible heap</gpuBudget>
    <safety>
      - Implement only what is necessary for A7 MVP; prefer additive changes, minimal surface area.
      - Never delete custom user code; for generated artifacts, add .gitignore entries rather than deleting tracked files.
      - If a tool is missing, mark step SKIPPED with the exact command to run locally.
      - If essential data is missing, reply <b>UNCERTAIN</b> with the precise artifact or decision required.
    </safety>
    <exclusions>.git, dist, build, .venv, venv, node_modules, __pycache__, *.png, *.jpg, *.pdf, *.whl, *.zip, *.tar.gz, out, diag_out</exclusions>
  </constraints>

  <inputs>
    <repoRoot>./</repoRoot>
    <roadmapPath>./roadmap2.csv</roadmapPath>
    <workstreamSelector>
      <![CDATA[
      ID: A
      Task: A7
      Title contains: LBVH/SAH Builder & Refit
      ]]>
    </workstreamSelector>
  </inputs>

  <!-- Read from roadmap2.csv (A7 row) -->
  <acceptanceCriteria>
    <ac id="AC-0">roadmap2.csv contains Workstream ID "A" and Task "A7" (case-insensitive). If not found → <b>UNCERTAIN</b> (list discovered A* tasks) and STOP.</ac>
    <ac id="AC-1">GPU LBVH build available with Morton codes + radix sort (WGSL compute), producing a compact, traversable BVH node array.</ac>
    <ac id="AC-2">CPU SAH builder exists as a fallback, API-compatible with GPU output format.</ac>
    <ac id="AC-3">Refit pass implemented (GPU preferred, CPU fallback) that updates internal node AABBs for modest per-frame motion without full rebuild.</ac>
    <ac id="AC-4">Public API exposes a single builder interface selecting GPU when available; deterministic seeding and stable outputs given identical inputs.</ac>
    <ac id="AC-5">Performance targets documented & smoke-validated: build ≤ ~1s for ~1M tris (debug builds may exceed; note in results); refit ≤ ~25ms; memory within budget.</ac>
    <ac id="AC-6">Unit/integration tests cover GPU build (skip if no adapter), CPU fallback, and refit correctness on a small moving-scene; docs updated.</ac>
  </acceptanceCriteria>

  <design>
    <dataModel>
      <![CDATA[
Node layout (SoA for GPU traversal; AoS for simplicity acceptable for MVP):
  struct Aabb { min: vec3<f32>, max: vec3<f32> }
  enum NodeKind { Internal{left:u32,right:u32}, Leaf{first:u32,count:u32} }
  struct BvhNode { aabb: Aabb, kind: u32, i0: u32, i1: u32 } // packed for GPU
Primitive index buffer: u32 per triangle; Morton code buffer: u32 (10-10-10 bits, grid 1024^3).
Coordinate normalization: world AABB → [0,1]^3; morton3D of centroids; clamp.
      ]]>
    </dataModel>

    <wgslKernels>
      <![CDATA[
Files:
  src/shaders/lbvh_morton.wgsl       // compute morton codes from primitive centroids
  src/shaders/radix_sort_pairs.wgsl  // key-value radix sort (codes, indices), 4-bit digit passes
  src/shaders/lbvh_link.wgsl         // build linear BVH topology from sorted codes (Karras-style)
  src/shaders/bvh_refit.wgsl         // bottom-up refit of AABBs

Common header in each WGSL:
  - Bind Group 0: Uniforms { prim_count:u32; frame_index:u32; world_min:vec3<f32>; world_extent:vec3<f32> }
  - Bind Group 1: readonly storage buffers: centroids[], prim_indices[]
  - Bind Group 2: readwrite storage buffers: morton_codes[], sorted_indices[] (for sort), nodes[], aabbs[]
  - @workgroup_size(256) for morton/sort; @workgroup_size(64) for link/refit (tune if needed)
      ]]>
    </wgslKernels>

    <rustAPI>
      <![CDATA[
Paths:
  src/accel/mod.rs                // new module root
  src/accel/types.rs              // AABB, Node, packing helpers
  src/accel/lbvh_gpu.rs           // orchestrates WGSL pipelines + dispatch (build + refit)
  src/accel/sah_cpu.rs            // CPU SAH builder (fallback)
  src/path_tracing/accel.rs       // glue for path tracer to consume BVH buffers

Key structs:
  pub struct GpuBvhBuilder { device: Arc<wgpu::Device>, queue: Arc<wgpu::Queue>, pipelines: Pipelines, … }
  pub struct CpuSahBuilder { … }
  pub enum BvhBackend { GPU(GpuBvh), CPU(CpuBvh) }
  pub struct Bvh { nodes: Buffer/Vec<BvhNode>, prim_indices: Buffer/Vec<u32>, world_aabb: Aabb, … }

Public API:
  pub fn build_bvh(scene:&[Triangle], opts:&BuildOptions, ctx:&GpuContextOption) -> anyhow::Result<Bvh>;
  pub fn refit_bvh(bvh:&mut Bvh, new_prim_aabbs:&[Aabb], ctx:&GpuContextOption) -> anyhow::Result<()>;
      ]]>
    </rustAPI>

    <pythonAPI>
      <![CDATA[
# python/forge3d/path_tracing.py
def build_bvh(primitives, use_gpu: bool = True, seed: int = 1) -> "BvhHandle": ...
def refit_bvh(handle: "BvhHandle", new_primitives) -> None: ...
# PathTracer uses GPU-built BVH when available; otherwise CPU SAH fallback.
      ]]>
    </pythonAPI>

    <risksMitigations>
      <![CDATA[
- GPU radix sort complexity: keep MVP single-GPU-pass radix with limited memory; fallback to CPU sort if WGSL path not available.
- Driver variability: detect unsupported features and fall back gracefully.
- Performance variance: document results; ensure correctness-first; gate perf checks as smoke tests.
      ]]>
    </risksMitigations>
  </design>

  <changes>
    <createOrModify>
      <!-- Rust -->
      <file path="src/accel/mod.rs" kind="new"/>
      <file path="src/accel/types.rs" kind="new"/>
      <file path="src/accel/lbvh_gpu.rs" kind="new"/>
      <file path="src/accel/sah_cpu.rs" kind="new"/>
      <file path="src/path_tracing/accel.rs" kind="new"/>

      <!-- WGSL -->
      <file path="src/shaders/lbvh_morton.wgsl" kind="new"/>
      <file path="src/shaders/radix_sort_pairs.wgsl" kind="new"/>
      <file path="src/shaders/lbvh_link.wgsl" kind="new"/>
      <file path="src/shaders/bvh_refit.wgsl" kind="new"/>

      <!-- Python bridge -->
      <file path="python/forge3d/path_tracing.py" kind="modify"/>

      <!-- Tests -->
      <file path="tests/test_bvh_gpu.rs" kind="new"/>
      <file path="tests/test_bvh_refit.rs" kind="new"/>
      <file path="tests/test_bvh_cpu_vs_gpu.py" kind="new"/>

      <!-- Docs -->
      <file path="README.md" kind="modify-append"/>
      <file path="docs/api/accel_bvh.md" kind="new-optional"/>

      <!-- Housekeeping -->
      <file path=".gitignore" kind="modify-append"/>
    </createOrModify>
  </changes>

  <tests>
    <rust path="tests/test_bvh_gpu.rs">
      <![CDATA[
#[test]
fn gpu_lbvh_build_small_scene() {
    // Build a few triangles, run GPU build if adapter available; assert node count and root AABB sane.
}
      ]]>
    </rust>
    <rust path="tests/test_bvh_refit.rs">
      <![CDATA[
#[test]
fn refit_updates_aabb_without_rebuild() {
    // Build once, then nudge a primitive; run refit; assert parent AABBs expanded accordingly.
}
      ]]>
    </rust>
    <python path="tests/test_bvh_cpu_vs_gpu.py">
      <![CDATA[
import pytest, numpy as np
from forge3d.path_tracing import build_bvh, refit_bvh
def test_cpu_gpu_equivalence_small():
    prims = make_unit_cube_tris()
    bvh_gpu = build_bvh(prims, use_gpu=True, seed=123)
    bvh_cpu = build_bvh(prims, use_gpu=False, seed=123)
    # Compare a subset: root AABB, leaf counts, and a hash of structure (tolerate minor ordering diffs).
      ]]>
    </python>
  </tests>

  <prechecks>
    <command>
      <![CDATA[
python - <<'PY'
import csv, codecs, sys
found=False
with codecs.open("roadmap2.csv","r","utf-8-sig") as f:
    rdr=csv.DictReader(f)
    for r in rdr:
        wid=str(r.get("Workstream ID","")).strip().lower()
        tid=str(r.get("Task Title","")).strip().lower()
        rat=str(r.get("Rationale","")).lower()
        if wid=="a" and ("a7"==tid or "a7" in tid) and ("bvh" in rat or "lbvh" in rat):
            found=True; break
if not found:
    print("UNCERTAIN: A7 not found in roadmap2.csv (Workstream A). Please confirm row and headers."); sys.exit(3)
print("WORKSTREAM_TASK_FOUND:A7")
PY
      ]]>
    </command>
  </prechecks>

  <!-- EXACTLY INCLUDE THESE STEPS -->
  <plan>
    5) Implementation (Write mode only if &lt;WRITE_CHANGES&gt;true&lt;/WRITE_CHANGES&gt;)
       - Create branch: <code>git checkout -b ws-&lt;ID-or-slug&gt;-implementation</code>
       - For each task in deterministic order (by Priority then Task ID):
         * Apply minimal changes.
         * Add/update tests when <USE_TESTS>true</USE_TESTS>.
         * Update docs (Sphinx/README) and example scripts if referenced by AC.
         * Update CI if <ENSURE_CI>true</ENSURE_CI> and AC requires.
         * Keep one commit per task: <code>git commit -am "WS&lt;ID&gt; &lt;TaskID&gt;: &lt;short summary&gt;"</code>
       - Maintain safety: never delete custom user code; only remove generated artifacts (.pyd/.so, build/ etc.) when explicitly required by AC; otherwise add .gitignore entries.

    6) Validation Run
       - Commands (skip gracefully if tool missing; record SKIPPED):
         * <code>cargo fmt -- --check</code>
         * <code>cargo clippy --all-targets --all-features -D warnings</code>
         * <code>cargo test -q</code>
         * <code>pytest -q</code> (when <USE_TESTS>true</USE_TESTS>)
         * <code>sphinx-build -b html docs _build/html</code>
         * <code>maturin build --release</code>
         * <code>cmake -S . -B build && cmake --build build</code> (if CMake wrapper is part of AC)
       - Re-run the audit matrix; all tasks should now be <b>Present & Wired</b>.
       - If any still failing → fix or mark explicitly BLOCKED with reason.

    7) PR Preparation
       - Generate <b>PR_BODY.md</b> summarizing: scope, tasks addressed, evidence, risks/mitigations, and validation output.
       - Print final change summary: <code>git status -s</code>, <code>git log --oneline -n 50</code>.
  </plan>

  <execution>
    <steps>
      <step>Create feature branch: <code>git checkout -b ws-A7-implementation</code></step>

      <!-- WGSL kernels -->
      <step>Add/implement WGSL: <code>src/shaders/lbvh_morton.wgsl</code>, <code>src/shaders/radix_sort_pairs.wgsl</code>, <code>src/shaders/lbvh_link.wgsl</code>, <code>src/shaders/bvh_refit.wgsl</code> with header docs (bind groups/bindings, formats, spaces).</step>

      <!-- Rust backend -->
      <step>Create Rust modules under <code>src/accel/</code> for GPU builder and CPU SAH fallback with identical output format; expose <code>build_bvh</code> and <code>refit_bvh</code>.</step>
      <step>Glue into path tracer via <code>src/path_tracing/accel.rs</code>; ensure traversal code can consume the produced BVH layout.</step>

      <!-- Python bridge -->
      <step>Modify <code>python/forge3d/path_tracing.py</code> to expose <code>build_bvh(..., use_gpu=True)</code> and <code>refit_bvh(...)</code>; default to GPU when available, otherwise CPU; preserve determinism for fixed inputs.</step>

      <!-- Tests -->
      <step>Add tests: Rust GPU build/refit and Python CPU-vs-GPU equivalence; mark GPU tests skipped when adapter unavailable.</step>

      <!-- Docs & housekeeping -->
      <step>Append <code>.gitignore</code> (out/, diag_out/, build artifacts); update <code>README.md</code> and (if present) <code>docs/api/accel_bvh.md</code> with usage and limitations.</step>

      <!-- Validation -->
      <step>Run the Validation Run commands; address non-flaky failures; document SKIPPED with exact commands.</step>

      <!-- PR -->
      <step>Generate <code>PR_BODY.md</code> and print <code>git status -s</code> and <code>git log --oneline -n 50</code>.</step>
    </steps>
  </execution>

  <completion>
    <print>
      - src/accel/mod.rs
      - src/accel/types.rs
      - src/accel/lbvh_gpu.rs
      - src/accel/sah_cpu.rs
      - src/path_tracing/accel.rs
      - src/shaders/lbvh_morton.wgsl
      - src/shaders/radix_sort_pairs.wgsl
      - src/shaders/lbvh_link.wgsl
      - src/shaders/bvh_refit.wgsl
      - python/forge3d/path_tracing.py
      - tests/test_bvh_gpu.rs
      - tests/test_bvh_refit.rs
      - tests/test_bvh_cpu_vs_gpu.py
      - README.md
      - docs/api/accel_bvh.md (if Sphinx present)
      - PR_BODY.md
    </print>
    <fallback>
      If A7 is not found in roadmap2.csv, respond <b>UNCERTAIN</b> with the list of detected A* tasks and STOP without changes.
    </fallback>
  </completion>
</task>
