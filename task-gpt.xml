<task id="ws-A17-auto" version="1.0">
  <title>Workstream A · Task A17 — Implement per roadmap2.csv (derive deliverables → code/tests/docs)</title>

  <role>
    You are OpenAI Codex CLI in <b>Verification → Implementation Mode</b>, acting as a senior graphics/runtime engineer.
    Stack: WebGPU/wgpu + WGSL, Rust, Python ≥3.8 (PyO3/maturin abi3), CMake ≥3.24, VMA, Sphinx.
    Project: forge3d — Rust backend + Python frontend for interactive/offline 3D visualization (terrain, maps, graphs).
  </role>

  <switches>
    <WRITE_CHANGES>true</WRITE_CHANGES>
    <USE_TESTS>true</USE_TESTS>
    <ENSURE_CI>true</ENSURE_CI>
  </switches>

  <constraints>
    <platforms>win_amd64, linux_x86_64, macos_universal2</platforms>
    <gpuBudget>≤ 512 MiB host-visible heap</gpuBudget>
    <safety>
      - Make only the minimal, additive changes needed to satisfy the A17 row’s Deliverables and Acceptance Criteria.
      - Preserve existing public APIs unless A17 explicitly calls out a breaking change; prefer opt-in flags/parameters.
      - Never delete custom user code; for generated artifacts, prefer adding .gitignore entries.
      - If a required tool is missing, mark the step SKIPPED with the exact command to run locally.
      - If the A17 row is missing/ambiguous, reply <b>UNCERTAIN</b> listing the exact headers/rows/fields needed, then STOP with no edits.
    </safety>
    <exclusions>.git, dist, build, .venv, venv, node_modules, __pycache__, *.png, *.jpg, *.pdf, *.whl, *.zip, *.tar.gz, out, diag_out</exclusions>
  </constraints>

  <inputs>
    <repoRoot>./</repoRoot>
    <roadmapPath>./roadmap2.csv</roadmapPath>
    <workstreamSelector>
      <![CDATA[
      Workstream ID: A
      Task ID: A17
      ]]>
    </workstreamSelector>
  </inputs>

  <!-- 1) Verify A17 exists and extract Title/Deliverables/Acceptance -->
  <prechecks>
    <command>
      <![CDATA[
python - <<'PY'
import csv, codecs, sys, json
row=None
try:
  with codecs.open("roadmap2.csv","r","utf-8-sig") as f:
    rdr=csv.DictReader(f)
    for r in rdr:
      wid=(r.get("Workstream ID","") or "").strip().lower()
      tid=(r.get("Task ID","") or "").strip().lower()
      ttl=(r.get("Task Title","") or "").strip().lower()
      if wid=="a" and (tid=="a17" or "a17" in ttl):
        row=r; break
except FileNotFoundError:
  print("UNCERTAIN: roadmap2.csv not found", file=sys.stderr); sys.exit(2)
if not row:
  print("UNCERTAIN: A17 not found in roadmap2.csv (Workstream A). Provide the exact row with headers.", file=sys.stderr); sys.exit(3)
meta={
  "Title": (row.get("Task Title","") or "").strip(),
  "Rationale": (row.get("Rationale","") or "").strip(),
  "Deliverables": (row.get("Deliverables","") or "").strip(),
  "Acceptance": (row.get("Acceptance Criteria","") or "").strip(),
  "Priority": (row.get("Priority","") or "").strip(),
  "Phase": (row.get("Phase","") or "").strip(),
  "Missing": (row.get("Missing Features","") or "").strip(),
  "Dependencies": (row.get("Dependencies","") or "").strip(),
  "Risks": (row.get("Risks/Mitigations","") or "").strip()
}
print("WORKSTREAM_TASK_FOUND:A17")
print("A17_META:"+json.dumps(meta, ensure_ascii=False))
PY
      ]]>
    </command>
  </prechecks>

  <design>
    <mappingRules>
      <![CDATA[
Turn A17 “Deliverables” text into concrete artifacts using these keyword→path rules (use exact filenames if the CSV specifies them; otherwise apply heuristics):

Core rendering:
- "WGSL", "compute", "shader", "kernel", "AOV" → src/shaders/<feature>.wgsl (+ header docs: bind groups/bindings, formats).
- "BVH", "accel", "traversal" → src/accel/*.rs, src/path_tracing/accel.rs (+ WGSL hooks).
- "intersection", "ray-triangle", "ray-sphere" → src/path_tracing/intersect.rs and/or src/shaders/pt_intersect_*.wgsl.
- "materials", "BSDF", "PBR", "BRDF", "GGX", "clearcoat", "sheen" → src/pbr/*.rs; shaders/pbr_*.wgsl; python/forge3d/pbr.py.
- "sampling", "MIS", "NEE", "alias", "reservoir", "light tree" → src/lighting/*.rs; shaders/lighting_*.wgsl; python/forge3d/lighting.py.
- "denoise", "SVGF", "temporal", "TAA" → src/denoise/*; shaders/svgf_*.wgsl; python/forge3d/path_tracing.py (flags).
- "wavefront", "queues", "compaction" → src/path_tracing/wavefront/**/*.rs; shaders/pt_*.wgsl.

Scene/content:
- "camera", "DOF", "thin lens", "motion vectors" → src/camera/*.rs; shaders/camera_*.wgsl; python/forge3d/camera.py.
- "textures", "image", "mipmap", "sampler" → src/textures/*.rs; shaders/texture_*.wgsl; python/forge3d/textures.py.
- "mesh", "OBJ", "PLY", "glTF", "USD", "tangents" → src/mesh/*.rs; python/forge3d/mesh_io.py.
- "terrain", "heightmap", "tile", "geospatial", "map" → src/terrain/*.rs; python/forge3d/terrain.py; shaders/terrain_*.wgsl.
- "graphs", "layouts", "instancing" → src/scene/graph.rs; python/forge3d/graph.py; shaders/instancing_*.wgsl.

Pipelines & UX:
- "tonemap", "ACES", "Reinhard", "exposure" → src/post/tonemap.rs; src/shaders/tonemap.wgsl; python bridge.
- "examples" → examples/<feature>_*.py (write to out/; ensure .gitignore ignores out/).
- "docs" → README.md + docs/api/<feature>.md (if Sphinx present).
- "Python API" → python/forge3d/<feature>.py (public class/functions + type hints).

Tests:
- "tests", "validation", "golden" → tests/<feature>_*.rs or tests/test_<feature>*.py (GPU tests @skip if no adapter).

If a deliverable is ambiguous or lacks keywords, mark UNCERTAIN for that bullet with the minimal clarification needed.
      ]]>
    </mappingRules>
  </design>

  <acceptanceCriteria>
    <ac id="AC-0">A17 row is present; meta printed as A17_META JSON.</ac>
    <ac id="AC-1">Every concrete deliverable item from A17’s Deliverables cell exists as code/docs/tests artifacts with appropriate header/inline docs (bind groups for WGSL, public APIs for Python/Rust, type hints for Python).</ac>
    <ac id="AC-2">Public Python API exposes the functions/classes required by A17’s Acceptance Criteria; deterministic behavior documented for frames=1 with fixed seed where applicable.</ac>
    <ac id="AC-3">Unit/integration tests exist for all implemented deliverables; GPU-dependent tests are skipped when no compatible adapter is available; failure modes are covered.</ac>
    <ac id="AC-4">Docs updated: README + docs/api/<feature>.md (if Sphinx present) clearly describing usage, parameters, conventions, and limitations; examples added if referenced.</ac>
    <ac id="AC-5">Validation run passes: fmt, clippy -D warnings, cargo test, pytest, sphinx-build (if docs), maturin build; CI ensured if missing.</ac>
  </acceptanceCriteria>

  <changes>
    <createOrModify>
      <!-- Actual files depend on A17 deliverables; these directories are typical targets -->
      <file path="src/shaders/" kind="modify-or-new"/>
      <file path="src/path_tracing/" kind="modify-or-new"/>
      <file path="src/accel/" kind="modify-or-new-optional"/>
      <file path="src/lighting/" kind="modify-or-new-optional"/>
      <file path="src/pbr/" kind="modify-or-new-optional"/>
      <file path="src/camera/" kind="modify-or-new-optional"/>
      <file path="src/textures/" kind="modify-or-new-optional"/>
      <file path="src/mesh/" kind="modify-or-new-optional"/>
      <file path="src/scene/" kind="modify-or-new-optional"/>
      <file path="src/terrain/" kind="modify-or-new-optional"/>
      <file path="src/denoise/" kind="modify-or-new-optional"/>
      <file path="python/forge3d/" kind="modify-or-new"/>
      <file path="tests/" kind="modify-or-new"/>
      <file path="examples/" kind="modify-or-new-optional"/>
      <file path="README.md" kind="modify-append"/>
      <file path="docs/api/" kind="modify-or-new-optional"/>
      <file path=".gitignore" kind="modify-append"/>
    </createOrModify>
  </changes>

  <tests>
    <templates>
      <![CDATA[
- GPU feature tests (pytest): skip if no adapter; assert shapes/dtypes; determinism for frames=1 with fixed seed; numeric assertions aligned with A17 AC (e.g., variance reduction, pdf normalization, bounds checks).
- Rust unit tests: struct packing/layout (assert_eq!(size_of::<T>(), ...)), math helpers, error handling (no panics across FFI).
- Docs build test: sphinx-build succeeds (or SKIPPED if docs absent).
- Example smoke test (optional): script runs headless and writes to out/ (gitignored).
      ]]>
    </templates>
  </tests>

  <!-- EXACTLY INCLUDE THESE STEPS -->
  <plan>
    5) Implementation (Write mode only if &lt;WRITE_CHANGES&gt;true&lt;/WRITE_CHANGES&gt;)
       - Create branch: <code>git checkout -b ws-&lt;ID-or-slug&gt;-implementation</code>
       - For each task in deterministic order (by Priority then Task ID):
         * Apply minimal changes.
         * Add/update tests when <USE_TESTS>true</USE_TESTS>.
         * Update docs (Sphinx/README) and example scripts if referenced by AC.
         * Update CI if <ENSURE_CI>true</ENSURE_CI> and AC requires.
         * Keep one commit per task: <code>git commit -am "WS&lt;ID&gt; &lt;TaskID&gt;: &lt;short summary&gt;"</code>
       - Maintain safety: never delete custom user code; only remove generated artifacts (.pyd/.so, build/ etc.) when explicitly required by AC; otherwise add .gitignore entries.

    6) Validation Run
       - Commands (skip gracefully if tool missing; record SKIPPED):
         * <code>cargo fmt -- --check</code>
         * <code>cargo clippy --all-targets --all-features -D warnings</code>
         * <code>cargo test -q</code>
         * <code>pytest -q</code> (when <USE_TESTS>true</USE_TESTS>)
         * <code>sphinx-build -b html docs _build/html</code>
         * <code>maturin build --release</code>
         * <code>cmake -S . -B build && cmake --build build</code> (if CMake wrapper is part of AC)
       - Re-run the audit matrix; all tasks should now be <b>Present & Wired</b>.
       - If any still failing → fix or mark explicitly BLOCKED with reason.

    7) PR Preparation
       - Generate <b>PR_BODY.md</b> summarizing: scope, tasks addressed, evidence, risks/mitigations, and validation output.
       - Print final change summary: <code>git status -s</code>, <code>git log --oneline -n 50</code>.
  </plan>

  <execution>
    <steps>
      <step>Create feature branch: <code>git checkout -b ws-A17-implementation</code></step>
      <step>Parse A17_META into bullet items (split by newlines/semicolons). Save mapping to <code>reports/a17_plan.json</code> (deliverable → files/symbols) using the mapping rules.</step>
      <step>For each mapped deliverable:
        <ul>
          <li>Implement minimal, correct code in WGSL/Rust/Python as indicated by A17 Deliverables and Acceptance Criteria.</li>
          <li>Add/modify tests (Rust/Python) covering success paths and at least one failure/validation path tied to the AC.</li>
          <li>Update README and docs/api/&lt;feature&gt;.md (if Sphinx present) with usage, parameters, conventions, and limitations.</li>
          <li>If examples requested: add example(s) in <code>examples/</code>, writing outputs to <code>out/</code> (ensure .gitignore ignores it).</li>
        </ul>
      </step>
      <step>Append <code>.gitignore</code> entries for out/, diag_out/, and build artifacts if needed.</step>
      <step>Run the Validation Run commands; fix non-flaky failures; mark SKIPPED where tools are absent and record the exact command.</step>
      <step>Create <code>PR_BODY.md</code> summarizing A17 implementation with references to files/lines and validation results; print <code>git status -s</code> and <code>git log --oneline -n 50</code>.</step>
    </steps>
  </execution>

  <completion>
    <print>
      - reports/a17_plan.json
      - All created/modified source files per mapping (WGSL/Rust/Python)
      - tests/* for implemented features
      - examples/* (if requested by A17)
      - README.md (updated)
      - docs/api/* (if Sphinx present)
      - PR_BODY.md
    </print>
    <fallback>
      If A17 is not found or its Deliverables/Acceptance text is empty/ambiguous, respond <b>UNCERTAIN</b> listing the exact missing fields and STOP without changes.
    </fallback>
  </completion>
</task>
