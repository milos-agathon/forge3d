<task id="ws-A20-A25-wireup" version="1.0">
  <title>Implement & wire missing/partial items for Workstream A</title>

  <role>
    You are Claude Code in Verification → Implementation Mode, acting as a senior graphics/runtime engineer.
    Stack: WebGPU/wgpu + WGSL, Rust, Python ≥3.8 (PyO3/maturin abi3), CMake ≥3.24, VMA, Sphinx.
    Project: forge3d — Rust backend + Python frontend for interactive/offline 3D visualization (terrain, maps, graphs).
  </role>

  <switches>
    <WRITE_CHANGES>true</WRITE_CHANGES>
    <USE_TESTS>true</USE_TESTS>
    <ENSURE_CI>true</ENSURE_CI>
  </switches>

  <constraints>
    <platforms>win_amd64, linux_x86_64, macos_universal2</platforms>
    <gpuBudget>≤ 512 MiB host-visible heap</gpuBudget>
    <toolchain>cmake≥3.24, cargo/rustc, PyO3, VMA, Sphinx</toolchain>
    <safety>
      - Minimal, additive changes to satisfy each task’s Deliverables and Acceptance Criteria (A20…A25).
      - Preserve existing public APIs unless a task explicitly calls for a breaking change; prefer opt-in flags/parameters.
      - Never delete custom user code; for generated artifacts prefer adding .gitignore entries instead of removing tracked files.
      - If a required tool is missing, mark the step SKIPPED with the exact command to run locally.
      - If any CSV field is missing/ambiguous for a targeted task, reply UNCERTAIN listing the exact row/field and STOP with no edits.
    </safety>
    <exclusions>.git, dist, build, .venv, venv, node_modules, __pycache__, *.png, *.jpg, *.pdf, *.whl, *.zip, *.tar.gz, out, diag_out</exclusions>
  </constraints>

  <inputs>
    <repoRoot>./</repoRoot>
    <paths>src/, shaders/, python/forge3d/, examples/, docs/</paths>
    <workstreamTasks>
      <task id="A19">Scene Cache for HQ</task>
      <task id="A20">Soft Area Lights Param</task>
      <task id="A21">Ambient Occlusion Integrator (Offline)</task>
      <task id="A22">Instanced Geometry (PT)</task>
      <task id="A23">Hair BSDF + Curve Prims (PT)</task>
      <task id="A24">Anisotropic Microfacet BRDF</task>
      <task id="A25">Object Importance Sampling</task>
    </workstreamTasks>
    <roadmapPath>./roadmap2.csv</roadmapPath>
  </inputs>

  <prechecks>
    <command>
      <![CDATA[
python - <<'PY'
import csv, codecs, sys, json
targets=["A19","A20","A21","A22","A23","A24","A25"]
found, missing = {}, []
try:
  with codecs.open("roadmap2.csv","r","utf-8-sig") as f:
    rdr=csv.DictReader(f)
    rows=list(rdr)
    for tid in targets:
      row=None
      for r in rows:
        if (r.get("Workstream ID","") or "").strip()=="A" and (r.get("Task ID","") or "").strip()==tid:
          row=r; break
      if not row:
        missing.append(tid); continue
      found[tid]={
        "Title": (row.get("Task Title","") or "").strip(),
        "Deliverables": (row.get("Deliverables","") or "").strip(),
        "Acceptance": (row.get("Acceptance Criteria","") or "").strip(),
        "Priority": (row.get("Priority","") or "").strip(),
        "Dependencies": (row.get("Dependencies","") or "").strip()
      }
except FileNotFoundError:
  print("UNCERTAIN: roadmap2.csv not found", file=sys.stderr); sys.exit(2)
if missing:
  print("UNCERTAIN: Missing Workstream A tasks in roadmap2.csv → "+", ".join(missing), file=sys.stderr); sys.exit(3)
for k,v in found.items():
  print(f"{k}_META:"+json.dumps(v, ensure_ascii=False))
PY
      ]]>
    </command>
    <note>
      Treat A19 as "Present & Wired" per audit; do not modify unless future audit changes status.
    </note>
  </prechecks>

  <design>
    <dependencyOrder>
      <![CDATA[
Derived from audit evidence and task relationships:
1) A24 Anisotropic Microfacet BRDF — foundational shading/tangent-frame work that others build upon.
2) A20 Soft Area Lights Param — depends on direct-light sampling/plumbing and shading correctness (A24).
3) A25 Object Importance Sampling — integrates with MIS weighting (lights/BSDF readiness from A20/A24).
4) A22 Instanced Geometry (PT) — wiring TLAS/instances into traversal; depends on stable PT buffers/layout.
5) A23 Hair BSDF + Curve Prims (PT) — shading + curve geometry after base shading/instances are ready.
6) A21 Ambient Occlusion Integrator (Offline) — mostly orthogonal; can be wired any time, scheduled last to avoid conflicts.
      ]]>
    </dependencyOrder>
    <mappingRules>
      <![CDATA[
Use CSV Deliverables keywords to map to concrete artifacts:
- "BRDF", "anisotropic", "tangent frame": src/shaders/pt_shade.wgsl; src/pbr/*; python/forge3d/path_tracing.py
- "area light", "radius", "vectors": src/shaders/lighting_area.wgsl; src/path_tracing/compute.rs; examples/*area_lights*.py
- "AO", "G-buffer", "cosine": src/shaders/ao_compute.wgsl; src/post/ambient_occlusion.rs; python/forge3d/ambient_occlusion.py
- "instances", "TLAS", "instance buffer": src/path_tracing/compute.rs; src/path_tracing/accel.rs; tests/*instances*; examples/*instances*.py
- "hair", "curve", "pigments", "widths": src/shaders/pt_hair.wgsl; src/path_tracing/curve.rs; python/forge3d/path_tracing.py
- "MIS", "tags", "importance": src/path_tracing/importance.rs; src/path_tracing/compute.rs; tests/*importance*.py
If any bullet lacks sufficient keywords, mark UNCERTAIN and STOP with the exact clarification needed.
      ]]>
    </mappingRules>
  </design>

  <acceptanceCriteria>
    <ac id="AC-0">A19 remains unmodified (Present & Wired). The consolidated changes affect only A20–A25.</ac>
    <ac id="AC-20">A20: “Penumbra widens with radius; energy within 2%.” Verified via test scene sweep of radius; numeric energy check within ±2%.</ac>
    <ac id="AC-21">A21: “4k AO ≤1s mid‑tier; quality parity.” Provide a scaled headless benchmark + a parity check vs reference statistics; document limits.</ac>
    <ac id="AC-22">A22: “10k instances with one BLAS; ≤512MiB VRAM.” Enforce a memory-budgeted test config; verify TLAS instance transforms applied.</ac>
    <ac id="AC-23">A23: “Hairball highlights/tilt match reference.” Add unit/integration coverage: shading lobes and at least one failure path.</ac>
    <ac id="AC-24">A24: “Aniso reduces to iso at ax=ay; energy conserved.” Numeric tests: when ax=ay, match isotropic GGX within tolerance; total energy within bounds.</ac>
    <ac id="AC-25">A25: “≥15% MSE ↓ on tagged objects w/o bias.” Headless A/B on a tagged-object setup; assert MSE improvement and no bias drift in mean luminance.</ac>
    <ac id="AC-BUILD">Validation runbook passes: cargo build/test; pytest (GPU tests skipped gracefully when adapter missing); sphinx-build if docs present; maturin build for ABI checks.</ac>
  </acceptanceCriteria>

  <changes>
    <createOrModify>
      <file path="src/shaders/" kind="modify-or-new"/>
      <file path="src/path_tracing/" kind="modify-or-new"/>
      <file path="src/pbr/" kind="modify-or-new-optional"/>
      <file path="src/post/" kind="modify-or-new-optional"/>
      <file path="python/forge3d/" kind="modify-or-new"/>
      <file path="tests/" kind="modify-or-new"/>
      <file path="examples/" kind="modify-or-new-optional"/>
      <file path="docs/api/" kind="modify-or-new-optional"/>
      <file path=".gitignore" kind="modify-append"/>
      <file path="README.md" kind="modify-append"/>
    </createOrModify>
  </changes>

  <plan>
    1) Create branch: <code>git checkout -b ws-A20-A25-wireup</code>
    2) Parse roadmap metadata for A20–A25 (prechecks). If any missing → UNCERTAIN and STOP.
    3) Implement in dependency order (A24 → A20 → A25 → A22 → A23 → A21):
       - For each task:
         * Implement minimal, correct code in WGSL/Rust/Python to meet CSV Deliverables.
         * Add/modify tests that cover success paths and at least one failure/validation path tied to the AC.
         * Update README and docs/api/&lt;feature&gt;.md with usage, parameters, conventions, limitations.
         * Add examples when useful to demonstrate AC measurements (headless friendly, write outputs to out/).
         * Commit: <code>git commit -am "WSA &lt;TaskID&gt;: &lt;short summary&gt;"</code>
    4) Append .gitignore entries for out/, diag_out/, and build artifacts if not present.
    5) Validation Run:
       - <code>cargo fmt -- --check</code>
       - <code>cargo build --all-features</code>
       - <code>cargo test -q</code>
       - <code>pytest -q</code> (GPU tests auto-skip if no compatible adapter)
       - <code>sphinx-build -b html docs _build/html</code> (SKIP if docs absent)
       - <code>maturin build --release</code>
       - Record any SKIPPED steps with exact commands.
    6) Re-run the A20–A25 AC-oriented tests; ensure all pass within tolerances and within the ≤512MiB budget.
    7) PR Preparation:
       - Generate PR_BODY.md summarizing scope, changes, evidence (files/lines), risks/mitigations, and validation output.
       - Print <code>git status -s</code> and <code>git log --oneline -n 50</code>.
  </plan>

  <execution>
    <steps>
      <step>Create feature branch</step>
      <step>Run prechecks and extract A20–A25 metadata (Deliverables/Acceptance/Deps)</step>
      <step>Implement A24 → A20 → A25 → A22 → A23 → A21 with per-task commit granularity</step>
      <step>Add/adjust tests and docs/examples aligned with each AC</step>
      <step>Run validation; fix non-flaky failures; record SKIPPED with exact commands if tools missing</step>
      <step>Create PR_BODY.md and print status/log</step>
    </steps>
  </execution>

  <completion>
    <print>
      - tests/* covering each implemented feature
      - src/shaders/* and associated Rust/Python sources touched by A20–A25
      - examples/* (if added)
      - docs/api/* (if added)
      - README.md (updated)
      - PR_BODY.md
    </print>
    <fallback>
      If any A20–A25 Deliverables/Acceptance text is empty or ambiguous in the CSV, respond UNCERTAIN listing the exact missing fields and STOP without changes.
    </fallback>
  </completion>
</task>