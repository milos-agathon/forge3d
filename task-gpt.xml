<task id="ws-A9-pbr-textures" version="1.0">
  <title>Workstream A · Task A9 — PBR Textures in Path Tracer (albedo/metallic/roughness/normal/emissive) with filtered sampling & tangents</title>

  <role>
    You are OpenAI Codex CLI in <b>Verification → Implementation Mode</b>, acting as a senior graphics/runtime engineer.
    Stack: WebGPU/wgpu + WGSL, Rust, Python ≥3.8 (PyO3/maturin abi3), CMake ≥3.24, VMA, Sphinx.
    Project: forge3d — Rust backend + Python frontend for interactive/offline 3D visualization.
  </role>

  <switches>
    <WRITE_CHANGES>true</WRITE_CHANGES>
    <USE_TESTS>true</USE_TESTS>
    <ENSURE_CI>true</ENSURE_CI>
  </switches>

  <constraints>
    <platforms>win_amd64, linux_x86_64, macos_universal2</platforms>
    <gpuBudget>≤ 512 MiB host-visible heap</gpuBudget>
    <safety>
      - Minimal, additive changes; do not break existing untextured PBR path.
      - Never delete custom user code; prefer adding .gitignore entries for generated artifacts.
      - If a tool is missing, mark the step SKIPPED with the exact command to run locally.
      - If roadmap data is missing/ambiguous, reply <b>UNCERTAIN</b> listing the exact CSV headers/rows needed.
    </safety>
    <exclusions>.git, dist, build, .venv, venv, node_modules, __pycache__, *.png, *.jpg, *.pdf, *.whl, *.zip, *.tar.gz, out, diag_out</exclusions>
  </constraints>

  <inputs>
    <repoRoot>./</repoRoot>
    <roadmapPath>./roadmap2.csv</roadmapPath>
    <workstreamSelector>
      <![CDATA[
      Workstream ID: A
      Task ID: A9
      Title contains: PBR Textures in PT
      ]]>
    </workstreamSelector>
  </inputs>

  <!-- Verify A9 exists in roadmap2.csv and capture its meta -->
  <prechecks>
    <command>
      <![CDATA[
python - <<'PY'
import csv, codecs, sys, json
row=None
try:
  with codecs.open("roadmap2.csv","r","utf-8-sig") as f:
    rdr=csv.DictReader(f)
    for r in rdr:
      wid=(r.get("Workstream ID","") or "").strip().lower()
      tid=(r.get("Task ID","") or "").strip().lower()
      ttl=(r.get("Task Title","") or "").strip().lower()
      if wid=="a" and (tid=="a9" or "a9" in ttl):
        row=r; break
except FileNotFoundError:
  print("UNCERTAIN: roadmap2.csv not found", file=sys.stderr); sys.exit(2)
if not row:
  print("UNCERTAIN: A9 not found in roadmap2.csv (Workstream A). Please confirm the exact row/headers.", file=sys.stderr); sys.exit(3)
meta={"Title":row.get("Task Title",""),
      "Rationale":row.get("Rationale",""),
      "Deliverables":row.get("Deliverables",""),
      "Acceptance":row.get("Acceptance Criteria",""),
      "Priority":row.get("Priority",""),
      "Phase":row.get("Phase",""),
      "Missing":row.get("Missing Features",""),
      "Dependencies":row.get("Dependencies",""),
      "Risks":row.get("Risks/Mitigations","")}
print("WORKSTREAM_TASK_FOUND:A9")
print("A9_META:"+json.dumps(meta, ensure_ascii=False))
PY
      ]]>
    </command>
  </prechecks>

  <acceptanceCriteria>
    <ac id="AC-1">WGSL compute path supports PBR textures: <b>albedo (sRGB)</b>, <b>metallic-roughness</b> (glTF convention: G=roughness, B=metallic), <b>normal map</b> (tangent space), and <b>emissive</b> (sRGB). Optional <b>occlusion</b> can be read but may be no-op for MVP.</ac>
    <ac id="AC-2">Filtered texture lookups in compute: mipmapped 2D sampled textures with <code>filtering=linear</code>, <code>address=repeat</code> (configurable); use <code>textureSample()</code> and correct LOD via implicit gradients; anisotropy not required.</ac>
    <ac id="AC-3">Tangent space normal mapping implemented: per-vertex tangents generated on CPU (MikkTSpace-like or MVP Gram-Schmidt), TBN built in shader, normal map scale applied; fall back gracefully if tangents absent.</ac>
    <ac id="AC-4">Rust backend provides texture loading & GPU upload (with mipmap generation on CPU), sampler creation, and bind group wiring; memory usage tracked to respect ≤512 MiB host-visible.</ac>
    <ac id="AC-5">Python API exposes a friendly way to attach texture sets to materials/meshes and to load images from disk or numpy arrays; sRGB↔linear handling is correct for baseColor/emissive.</ac>
    <ac id="AC-6">Correctness tests: (a) GPU test renders a textured quad/sphere; (b) normal map visibly perturbs shading (numeric assertion on variance/mean normal dot-L change); (c) CPU fallback path executes without error; GPU tests skip if no adapter.</ac>
    <ac id="AC-7">Parity note: provide a small smoke comparison harness and document that on a reference scene the average color difference vs raster PBR is targeted at ΔE≤3 (informational if raster baseline unavailable in CI).</ac>
    <ac id="AC-8">Docs updated (README + docs/api if present) describing texture conventions, glTF channel mapping, normal scale, and examples; examples write outputs to <code>out/</code> (gitignored).</ac>
    <ac id="AC-9">Validation passes: <code>cargo fmt</code>, <code>cargo clippy -D warnings</code>, <code>cargo test</code>, <code>pytest</code>, <code>sphinx-build</code> (if docs), <code>maturin build</code>; CI ensured.</ac>
  </acceptanceCriteria>

  <design>
    <wgsl>
      <![CDATA[
New/updated shader files:
  src/shaders/pbr_textured.wgsl     // sampling helpers + material fetch
  (extend) src/shaders/pt_shade.wgsl or pt_kernel.wgsl — integrate texture reads into BRDF

Header docs (each WGSL file MUST list bind groups/bindings):
Bind Group 0 — Uniforms:
  width, height, frame_index, exposure, seed_hi/lo, flags (bitmask enabling textures)
Bind Group 1 — Scene/Geometry (readonly buffers):
  vertices, indices, materials, uvs, tangents (optional), bvh (if using meshes)
Bind Group 2 — Textures/Samplers:
  @binding(0) texture_2d<f32>  baseColorTex   (sRGB → linear conversion in shader)
  @binding(1) texture_2d<f32>  mrTex          (R: occlusion opt., G: roughness, B: metallic)
  @binding(2) texture_2d<f32>  normalTex      (tangent-space, +Y up convention)
  @binding(3) texture_2d<f32>  emissiveTex    (sRGB → linear)
  @binding(4) sampler          linearRepeatSampler

Notes:
  - Base color sampled as sRGB, converted to linear via pow or fast_srgb_to_linear.
  - Metallic & roughness read from mrTex.g (Roughness), mrTex.b (Metallic); clamp [0,1].
  - Normal map unpack: n = normalize(2*rgb-1); build TBN: T,B,N from per-vertex attributes; Nshading = normalize(T*(n.x*scale)+B*(n.y*scale)+N*n.z)
  - Emissive sampled sRGB→linear; multiplied by emissiveFactor.
      ]]>
    </wgsl>

    <rustBackend>
      <![CDATA[
New modules (or extend existing):
  src/textures/mod.rs             // image loading, mipmap generation (box or Lanczos), wgpu texture upload
  src/path_tracing/materials.rs   // PbrMaterial { base_color_factor, metallic_factor, roughness_factor, emissive_factor, texture_handles }
  src/path_tracing/mod.rs         // integrate textures/samplers into bind groups; pass factors to shader

Key APIs:
  pub struct TextureHandle { view: wgpu::TextureView, format: wgpu::TextureFormat, size: (u32,u32), mip_level_count:u32 }
  pub fn upload_rgba8_srgb(device:&wgpu::Device, queue:&wgpu::Queue, data:&[u8], w:u32, h:u32, generate_mips:bool) -> TextureHandle
  pub fn generate_mips_cpu(rgba8:&mut [u8], w:u32, h:u32) -> Vec<(Vec<u8>, (u32,u32))> // MVP

Samplers:
  linearRepeatSampler: mag=min=linear, mipmap=linear, address_mode_{u,v}=repeat

Tangent generation (CPU, MVP):
  - For each triangle, compute tangent/bitangent from UV gradients; orthonormalize with normal (Gram-Schmidt); store per-vertex avg; normalize.
      ]]>
    </rustBackend>

    <pythonAPI>
      <![CDATA[
python/forge3d/textures.py (new):
  def load_texture(path_or_array, srgb:bool) -> "Tex": ...
  def build_pbr_textures(base_color=None, metallic_roughness=None, normal=None, emissive=None, *, srgb_defaults=True) -> "PbrTexSet": ...

python/forge3d/materials.py (new or extend):
  class PbrMaterial:
      def __init__(..., base_color_factor=(1,1,1,1), metallic_factor=1.0, roughness_factor=1.0, emissive_factor=(0,0,0)):
          ...
      def with_textures(self, texset:"PbrTexSet") -> "PbrMaterial": ...

python/forge3d/path_tracing.py (modify):
  def render_rgba(..., material: "PbrMaterial|None"=None, use_gpu:bool=True, seed:int=1, frames:int=1) -> np.ndarray:
      - If material has textures → enable textured BRDF path; else use factors only.
      - Deterministic for frames==1 with fixed seed.
      ]]>
    </pythonAPI>

    <examples>
      <![CDATA[
examples/textured_sphere.py — load checkerboard baseColor + normal ripple; render at 256×256; save out/textured_sphere.png
examples/textured_quad_gltf_like.py — synthesize MR channels; show roughness/metallic variation bands; save output
      ]]>
    </examples>

    <risksMitigations>
      <![CDATA[
- sRGB handling: convert only baseColor/emissive; MR and normal stay linear.
- Memory: reuse one staging buffer per upload; prefer RGBA8 formats; keep mips; free temporary CPU mip buffers.
- Tangent quality: MVP generator is sufficient; allow swapping with MikkTSpace later.
- glTF channel mapping: document convention; add unit test asserting G→roughness, B→metallic.
      ]]>
    </risksMitigations>
  </design>

  <changes>
    <createOrModify>
      <!-- WGSL -->
      <file path="src/shaders/pbr_textured.wgsl" kind="new"/>
      <file path="src/shaders/pt_shade.wgsl" kind="modify-or-new"/>
      <file path="src/shaders/pt_kernel.wgsl" kind="modify"/>

      <!-- Rust -->
      <file path="src/textures/mod.rs" kind="new"/>
      <file path="src/path_tracing/materials.rs" kind="new-or-modify"/>
      <file path="src/path_tracing/mod.rs" kind="modify"/>

      <!-- Python -->
      <file path="python/forge3d/textures.py" kind="new"/>
      <file path="python/forge3d/materials.py" kind="new-or-modify"/>
      <file path="python/forge3d/path_tracing.py" kind="modify"/>

      <!-- Tests -->
      <file path="tests/test_pbr_textures_gpu.py" kind="new"/>
      <file path="tests/test_tangent_generation.rs" kind="new"/>
      <file path="tests/test_gltf_mr_channels.py" kind="new"/>

      <!-- Examples & docs -->
      <file path="examples/textured_sphere.py" kind="new-optional"/>
      <file path="examples/textured_quad_gltf_like.py" kind="new-optional"/>
      <file path="README.md" kind="modify-append"/>
      <file path="docs/api/pbr_textures.md" kind="new-optional"/>
      <file path=".gitignore" kind="modify-append"/>
    </createOrModify>

    <implNotes>
      <![CDATA[
- WGSL fast sRGB→linear: pow(c, vec3(2.2)) MVP is acceptable; switchable to piecewise curve later.
- Normal map unpack uses OpenGL-style [+Y up]; if glTF uses same, OK; otherwise expose flipY flag.
- Use a single bind group for textures for MVP; material index selects which texture set to use per-primitive.
- For CPU fallback (if any), keep untextured path working; texture code is GPU-first.
      ]]>
    </implNotes>
  </changes>

  <tests>
    <python path="tests/test_pbr_textures_gpu.py">
      <![CDATA[
import numpy as np, pytest
from forge3d.path_tracing import PathTracer, make_camera
from forge3d.textures import build_pbr_textures
from forge3d.materials import PbrMaterial

def _checker_rgba8(w=64,h=64):
    img = np.zeros((h,w,4), dtype=np.uint8)
    for y in range(h):
        for x in range(w):
            v = 255 if ((x//8 + y//8) % 2)==0 else 0
            img[y,x] = (v, v, v, 255)
    return img

@pytest.mark.skipif(False, reason="Inject GPU-skip in CI if needed")
def test_textured_sphere_normalmap_affects_shading():
    base = _checker_rgba8()
    # fake MR: roughness in G, metallic in B
    mr = np.zeros((64,64,4), dtype=np.uint8); mr[...,1] = 64; mr[...,2] = 0
    # simple normal bump (encode +Y up)
    nrm = np.zeros((64,64,4), dtype=np.uint8); nrm[...,0]=128; nrm[...,1]=255; nrm[...,2]=128; nrm[...,3]=255
    tex = build_pbr_textures(base_color=base, metallic_roughness=mr, normal=nrm, emissive=None)
    mat = PbrMaterial().with_textures(tex)
    cam = make_camera(origin=(0,0,2.5), look_at=(0,0,0), up=(0,1,0), fov_y=45.0, aspect=1.0, exposure=1.0)
    tr = PathTracer()
    img_no = tr.render_rgba(64,64, scene=None, camera=cam, material=PbrMaterial(), seed=7, frames=1, use_gpu=True)
    img_tx = tr.render_rgba(64,64, scene=None, camera=cam, material=mat, seed=7, frames=1, use_gpu=True)
    assert img_tx.shape == img_no.shape
    # normal mapping should change shading (mean absolute difference threshold)
    mad = np.abs(img_tx.astype(np.int16)-img_no.astype(np.int16)).mean()
    assert mad > 1.0
      ]]>
    </python>

    <rust path="tests/test_tangent_generation.rs">
      <![CDATA[
#[test]
fn tangents_orthonormalize_with_normals() {
    // Build a single triangle with UVs; run tangent generator; check T ⟂ N and |T|≈1
}
      ]]>
    </rust>

    <python path="tests/test_gltf_mr_channels.py">
      <![CDATA[
import numpy as np
from forge3d.textures import build_pbr_textures

def test_mr_channel_mapping():
    mr = np.zeros((4,4,4), dtype=np.uint8)
    mr[...,1] = 255  # roughness=1.0
    mr[...,2] = 0    # metallic=0.0
    t = build_pbr_textures(metallic_roughness=mr)
    # This test asserts mapping/documentation rather than rendering
    assert t.meta["mapping"] == {"roughness":"G","metallic":"B","occlusion":"R(optional)"}
      ]]>
    </python>
  </tests>

  <!-- EXACTLY INCLUDE THESE STEPS -->
  <plan>
    5) Implementation (Write mode only if &lt;WRITE_CHANGES&gt;true&lt;/WRITE_CHANGES&gt;)
       - Create branch: <code>git checkout -b ws-&lt;ID-or-slug&gt;-implementation</code>
       - For each task in deterministic order (by Priority then Task ID):
         * Apply minimal changes.
         * Add/update tests when <USE_TESTS>true</USE_TESTS>.
         * Update docs (Sphinx/README) and example scripts if referenced by AC.
         * Update CI if <ENSURE_CI>true</ENSURE_CI> and AC requires.
         * Keep one commit per task: <code>git commit -am "WS&lt;ID&gt; &lt;TaskID&gt;: &lt;short summary&gt;"</code>
       - Maintain safety: never delete custom user code; only remove generated artifacts (.pyd/.so, build/ etc.) when explicitly required by AC; otherwise add .gitignore entries.

    6) Validation Run
       - Commands (skip gracefully if tool missing; record SKIPPED):
         * <code>cargo fmt -- --check</code>
         * <code>cargo clippy --all-targets --all-features -D warnings</code>
         * <code>cargo test -q</code>
         * <code>pytest -q</code> (when <USE_TESTS>true</USE_TESTS>)
         * <code>sphinx-build -b html docs _build/html</code>
         * <code>maturin build --release</code>
         * <code>cmake -S . -B build && cmake --build build</code> (if CMake wrapper is part of AC)
       - Re-run the audit matrix; all tasks should now be <b>Present & Wired</b>.
       - If any still failing → fix or mark explicitly BLOCKED with reason.

    7) PR Preparation
       - Generate <b>PR_BODY.md</b> summarizing: scope, tasks addressed, evidence, risks/mitigations, and validation output.
       - Print final change summary: <code>git status -s</code>, <code>git log --oneline -n 50</code>.
  </plan>

  <execution>
    <steps>
      <step>Create feature branch: <code>git checkout -b ws-A9-implementation</code></step>
      <step>Add WGSL sampling helpers and integrate into shading; extend bind groups with textures + sampler and document them in headers.</step>
      <step>Implement Rust texture upload with CPU mipmap generation; create linear-repeat sampler; wire material factors + texture sets to shader.</step>
      <step>Add CPU tangent generator; upload tangents per-vertex; build TBN in shader and apply normal map scale.</step>
      <step>Extend Python API to load/attach texture sets; update path_tracing render function to enable textured mode when material has textures.</step>
      <step>Create tests for GPU textured render, tangent generation, and glTF MR channel mapping; add examples.</step>
      <step>Docs & housekeeping: update <code>README.md</code>, add <code>docs/api/pbr_textures.md</code> (if Sphinx), and append <code>.gitignore</code> (e.g., out/).</step>
      <step>Run Validation Run commands; fix non-flaky failures; mark SKIPPED where tools are absent.</step>
      <step>Generate <code>PR_BODY.md</code> and print <code>git status -s</code> and <code>git log --oneline -n 50</code>.</step>
    </steps>
  </execution>

  <completion>
    <print>
      - src/shaders/pbr_textured.wgsl
      - src/shaders/pt_shade.wgsl
      - src/shaders/pt_kernel.wgsl
      - src/textures/mod.rs
      - src/path_tracing/materials.rs
      - src/path_tracing/mod.rs
      - python/forge3d/textures.py
      - python/forge3d/materials.py
      - python/forge3d/path_tracing.py
      - tests/test_pbr_textures_gpu.py
      - tests/test_tangent_generation.rs
      - tests/test_gltf_mr_channels.py
      - examples/textured_sphere.py
      - examples/textured_quad_gltf_like.py
      - README.md
      - docs/api/pbr_textures.md (if Sphinx present)
      - PR_BODY.md
    </print>
    <fallback>
      If A9 is not found in roadmap2.csv, respond <b>UNCERTAIN</b> with the list of detected Workstream A tasks and STOP without changes.
    </fallback>
  </completion>
</task>
