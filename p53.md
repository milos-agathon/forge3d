## Milestone 0 – Harness, scene, and meta plumbing

**Goal:** Have a repeatable test scene + reporting path for all later milestones.

### Scope / Tasks

1. **Test scene setup**

   * Add a dedicated P5.3 scene preset:

     * Row of 9 spheres with roughness `r = 0.1, 0.2, …, 0.9`.
     * Bright horizontal emissive stripe behind/above them.
     * Simple sky/IBL environment (HDR or analytic).
   * Fixed camera, resolution, exposure, tonemapper (ACES if that’s your default).

2. **Report plumbing**

   * Extend `reports/p5/p5_meta.json` with an empty `"ssr"` section and fields:

     ```json
     "ssr": {
       "hit_rate": 0.0,
       "avg_steps": 0.0,
       "miss_ibl_ratio": 0.0,
       "perf_ms": {
         "trace_ms": 0.0,
         "shade_ms": 0.0,
         "fallback_ms": 0.0,
         "total_ssr_ms": 0.0
       }
     }
     ```
   * Add harness code for:

     * Running the **glossy spheres** scene.
     * Capturing per-pixel “hit/miss” flags and step counts.
     * Writing metrics into the `"ssr"` block.

3. **CL / viewer parameters (stubbed)**

   * Define hot params (wiring can be no-op initially):

     * `--ssr-max-steps <int>`
     * `--ssr-thickness <float>`
     * `--ssr-enable on|off`

### Deliverables

* Scene preset committed (e.g. `p5_ssr_scene.json` or equivalent).
* `reports/p5/p5_meta.json` updated with `"ssr"` section (values can be 0.0 for now).
* Harness function to run `p5_ssr_glossy_spheres` pass without SSR (baseline only).

**Exit criteria:** Scene loads and renders (no SSR yet), meta file writes an `"ssr"` block with defaulted metrics.

---

## Milestone 1 – Core SSR tracing (WGSL trace + Rust pass skeleton)

**Goal:** Screen-space ray marching that finds hits in the depth buffer using HZB or thickness, with metrics wired.

### Scope / Tasks

1. **WGSL: `src/shaders/ssr/trace.wgsl`**

   * Inputs:

     * G-buffer view-space normals.
     * G-buffer depths (full-res).
     * Hierarchical Z-buffer (HZB) OR packed depth+thickness buffer.
     * Per-frame params: `ssr_max_steps`, `ssr_thickness`.
   * For each full-res pixel:

     * Reconstruct view-space position and normal.
     * Reflect view ray about the normal.
     * Ray-march in screen space:

       * Project reflected ray into screen UV.
       * Use HZB or thickness to detect intersection:

         * Early out on hit.
         * Miss if out of frustum, max steps exceeded, or behind surfaces thicker than `ssr_thickness`.
     * Outputs per-pixel:

       * `hit_uv` (float2).
       * `hit_mask` (0/1).
       * `steps_taken` (uint).
       * Optional `valid` flag for out-of-frustum.

2. **Rust: `src/passes/ssr.rs` (skeleton)**

   * Create textures/buffers:

     * SSR trace output (hit UV + mask + steps).
   * Dispatch `ssr/trace.wgsl`:

     * Binds G-buffer, HZB/depth, params.
   * Collect metrics:

     * `hit_rate = hits / total_pixels`.
     * `avg_steps = sum(steps_taken) / max(hits,1)`.
     * `miss_ibl_ratio` can remain 0.0 for now.
     * `perf_ms.trace_ms` measured around trace dispatch.

3. **CLI / viewer wiring**

   * Actually pass `--ssr-max-steps` and `--ssr-thickness` into the uniforms used by `trace.wgsl`.
   * Add `--ssr-enable` toggle that turns the whole pass on/off (for now, only trace).

### Deliverables

* `src/shaders/ssr/trace.wgsl` implemented with HZB/thickness test.
* `src/passes/ssr.rs` with working trace dispatch + metrics collection.
* `reports/p5/p5_meta.json` `"ssr"` updated after a run with:

  * non-zero `hit_rate` and `avg_steps`.
  * non-zero `perf_ms.trace_ms`.
* Debug visualization (internal-only OK) that shows hit vs miss mask for the spheres frame to verify ray marching sanity.

**Exit criteria:** Trace pass runs without shading; meta shows sensible hit rate and average steps (neither 0 nor 1.0 everywhere).

---

## Milestone 2 – Shading, Fresnel & roughness weighting (SSR + direct spec compositing)

**Goal:** Use the trace results to sample specular color and apply Fresnel/roughness weighting; integrate before tonemap after direct spec.

### Scope / Tasks

1. **WGSL: `src/shaders/ssr/shade.wgsl`**

   * Inputs:

     * Hit data from `ssr/trace.wgsl`.
     * Current frame color **or** pre-tonemap specular buffer.
     * Material properties: roughness, F0 (base reflectivity), normal, view vector.
   * For hits:

     * Sample reflection color at `hit_uv` from:

       * Either current color buffer (if no feedback issues), or
       * A dedicated pre-tonemap specular buffer.
     * Evaluate Fresnel Schlick:

       * `F = F0 + (1 - F0) * (1 - V·H)^5` (or equivalent).
     * Roughness-based cone weighting:

       * Modulate contribution by `(1 - roughness)` or physically-based lobe approximation.
   * For misses:

     * Write a sentinel value or zero; final color for misses will be handled by `fallback_env.wgsl`.

2. **WGSL: `src/shaders/ssr/fallback_env.wgsl`**

   * Inputs:

     * View vector, reflection vector, environment (IBL).
     * Hit/miss mask from trace/shade.
   * For **miss pixels or invalid hits**:

     * Sample environment reflection (matching your existing env spec).
   * For **hit pixels**:

     * Pass through SSR result (from shade) unchanged.
   * Output:

     * Final specular reflection buffer (linear, pre-tonemap).

3. **Rust: `src/passes/ssr.rs` composition order**

   * Ensure order:

     1. Direct specular lighting.
     2. SSR trace.
     3. SSR shade.
     4. SSR env fallback.
     5. Composite SSR buffer into main lighting buffer **before tonemap**.
   * Add timings:

     * `perf_ms.shade_ms`.
     * `perf_ms.fallback_ms`.
     * `perf_ms.total_ssr_ms = trace + shade + fallback (+ any resolve)`.

4. **Roughness sweep render**

   * For `p5_ssr_glossy_spheres` scene:

     * Render with SSR ON (no thickness ablation yet).
     * Capture `reports/p5/p5_ssr_glossy_spheres.png`:

       * Left to right: spheres with `r=0.1...0.9` clearly reflecting the bright stripe + sky.

5. **Stripe contrast metric**

   * Implement metric in harness:

     * For each sphere, define a small ROI where the reflected stripe appears.
     * Compute “stripe contrast” per roughness (e.g., local max-min or RMS contrast).
     * Record `ssr.stripe_contrast[r_index]` in `p5_meta.json` or at least:

       ```json
       "ssr_stripe_contrast": [ c_r0_1, c_r0_2, ..., c_r0_9 ]
       ```
   * Verify monotonic drop:

     * `contrast(r=0.1) > contrast(0.2) > … > contrast(0.9)`.

### Deliverables

* `src/shaders/ssr/shade.wgsl` implemented.
* `src/shaders/ssr/fallback_env.wgsl` implemented.
* `src/passes/ssr.rs` updated to composite SSR before tonemap and after direct spec.
* `reports/p5/p5_ssr_glossy_spheres.png` generated.
* `p5_meta.json` updated with:

  * `ssr.perf_ms.shade_ms`, `ssr.perf_ms.fallback_ms`, `ssr.perf_ms.total_ssr_ms`.
  * `ssr_stripe_contrast` array (monotonic drop is **goal but not yet hard-gated** here).

**Exit criteria:** Spheres visually show stronger reflections at low roughness, fading as roughness increases; metrics exist for stripe contrast.

---

## Milestone 3 – Thickness / HZB ablation & IBL fallback correctness

**Goal:** Show how thickness fixes undershoot artifacts and verify miss→IBL behavior quantitatively.

### Scope / Tasks

1. **Thickness ablation test**

   * Add a harness mode that:

     * Renders a scene where SSR rays intersect geometry at shallow angles (prone to undershoot).
     * Runs SSR twice:

       * A: `ssr_thickness = 0` (or thickness test disabled).
       * B: `ssr_thickness = default` (e.g., a small positive value matching scene scale).
   * Save a side-by-side image:

     * `reports/p5/p5_ssr_thickness_ablation.png`:

       * Left: no thickness (visible undershoot / “floating” reflections).
       * Right: thickness enabled (artifacts reduced/removed).

2. **Miss→IBL ratio**

   * In `src/passes/ssr.rs`, during shade or fallback:

     * Count how many pixels used env fallback vs SSR hit.
     * Set `ssr.miss_ibl_ratio = fallback_pixels / total_pixels`.
   * Ensure this value is sensible (neither 0 nor 1 for the spheres test).

3. **Fallback ΔE + black-hole check**

   * Implement explicit test path in harness:

     * For a frame with SSR enabled:

       * Render **SSR result** as usual.
       * Render a **pure IBL reflection reference** (no SSR, same env BRDF).
       * Compare them at pixels tagged as `miss` in trace output.
     * For miss pixels:

       * Compute `ΔE` (CIEDE2000 or reasonable approximation) between SSR output (which should be env) and pure IBL.
       * Track `max_delta_e` over misses.
       * Track `min_rgb` over misses.
   * Write to `p5_meta.json`:

     ```json
     "ssr": {
       ...
       "max_delta_e_miss": <float>,
       "min_rgb_miss": <float>
     }
     ```
   * Acceptance targets:

     * `max_delta_e_miss ≤ 2.0`
     * `min_rgb_miss ≥ 2.0 / 255.0` (no black holes).

### Deliverables

* `reports/p5/p5_ssr_thickness_ablation.png` generated (visibly worse on left, fixed on right).
* `p5_meta.json` updated with:

  * `ssr.miss_ibl_ratio`.
  * `ssr.max_delta_e_miss`.
  * `ssr.min_rgb_miss`.

**Exit criteria:**

* Visual evidence of thickness fixing undershoot.
* Miss pixels match IBL within ΔE ≤ 2, no black holes.

---

## Milestone 4 – Edge cleanup & final acceptance checks

**Goal:** Ensure SSR is stable at depth discontinuities and all acceptance criteria are programmatically checked.

### Scope / Tasks

1. **Edge resolve (no bright 1-px streaks)**

   * Identify or create a scene with strong depth discontinuities (e.g., near-silhouette geometry against sky) where SSR streaking can occur.
   * If needed, add a small post-resolve filter or clamp in `ssr/shade.wgsl` or a separate `ssr/resolve_edges.wgsl`:

     * Detect pixels where:

       * Neighboring depth/normal differ sharply, and
       * Specular value is a strong outlier vs local neighborhood.
     * Clamp or smooth such outliers to prevent >1-pixel bright streaks.
   * Implement a metrics pass:

     * Run an edge detector on the final SSR-composited image.
     * Count runs of contiguous bright pixels along edges where streak length > 1 pixel.
     * Store:

       ```json
       "ssr_edge_streaks": {
         "num_streaks_gt1px": <int>
       }
       ```
     * Target: `num_streaks_gt1px == 0` (or ≤ small tolerance if needed).

2. **Monotonic reflectivity vs roughness (hard gate)**

   * Promote the stripe contrast check from Milestone 2 into a hard acceptance.
   * After rendering `p5_ssr_glossy_spheres.png`:

     * Ensure the `ssr_stripe_contrast` array is strictly decreasing (or non-increasing with a small epsilon tolerance) from `r=0.1` to `r=0.9`.
     * If not, log failure and optionally write a `"status": "FAIL: ssr_stripe_contrast"` string in meta.

3. **Final meta status**

   * Add a `"ssr_status"` or fold into global `"status"` with a composite result:

     * `OK` iff:

       * Stripe contrast monotonic (within tolerance).
       * `max_delta_e_miss ≤ 2.0`.
       * `min_rgb_miss ≥ 2/255`.
       * `ssr_edge_streaks.num_streaks_gt1px == 0` (or within agreed tolerance).
     * Otherwise encode a clear failure message.

### Deliverables

* No new images required, but:

  * Updated `p5_ssr_glossy_spheres.png` and `p5_ssr_thickness_ablation.png` if the resolve pass changes visuals.
* `p5_meta.json` final fields:

  * `"ssr"` block with:

    * `hit_rate`, `avg_steps`, `miss_ibl_ratio`.
    * `perf_ms.trace_ms`, `shade_ms`, `fallback_ms`, `total_ssr_ms`.
    * `max_delta_e_miss`, `min_rgb_miss`.
  * `"ssr_stripe_contrast"` array (monotonic).
  * `"ssr_edge_streaks.num_streaks_gt1px"`.
  * `"ssr_status": "OK"` (or `"FAIL: …"` with cause).

**Exit criteria (P5.3 fully satisfied):**

1. **Reflectivity vs roughness:**
   `ssr_stripe_contrast` decreases monotonically as `r` goes from 0.1 to 0.9.

2. **Fallback:**
   `ssr.max_delta_e_miss ≤ 2.0` and `ssr.min_rgb_miss ≥ 2.0/255.0`.

3. **Edges:**
   No >1-pixel bright streaks at depth discontinuities after resolve
   (`ssr_edge_streaks.num_streaks_gt1px == 0` or agreed tolerance).

4. **Meta & images:**
   `p5_ssr_glossy_spheres.png`, `p5_ssr_thickness_ablation.png`, and `p5_meta.json` regenerate cleanly from the harness.
