**PROMPT FOR CODEX (M2 – SSR METRICS + ANALYSIS COMPLETION)**

You are updating the forge3d P5 SSR milestone to fully complete **M2**.

### 0. Context (do not change)

* Language: **Rust + WGSL**.
* Existing SSR files:

  * `src/passes/ssr.rs`
  * `src/shaders/ssr/trace.wgsl`
  * `src/shaders/ssr/shade.wgsl`
  * `src/shaders/ssr/fallback_env.wgsl`
* P5 harness & viewer:

  * `examples/p5_ssr_glossy.rs` (headless harness)
  * `src/viewer/mod.rs` (`capture_p53_ssr_glossy`, `capture_p5*` commands)
* Meta writer:

  * `src/p5/meta.rs` (`write_p5_meta(...)`)
* Current outputs in `reports/p5`:

  * `p5_ssr_glossy_reference.png`  (SSR disabled)
  * `p5_ssr_glossy_spheres.png`    (SSR enabled)
  * `p5_ssr_trace_mask.png`
  * `p5_ssr_thickness_ablation.png`
  * `p5_meta.json`

Do **not** rename any of these files or break existing commands:

* `cargo run --release --example p5_ssr_glossy`
* `cargo run --release --example p5_ssr_thickness_ablation`

Your job is to **finish M2** by wiring correct stats and analysis into `p5_meta.json`, without changing the visual SSR behavior.

---

### 1. Introduce an `SsrStats` aggregation and wire it through the pipeline

**Goal:** `meta["ssr"]` must contain **real, non-zero values** for all fields.

1.1. In `src/passes/ssr.rs` define:

```rust
pub struct SsrStats {
    pub num_rays: u32,
    pub num_hits: u32,
    pub total_steps: u32,
    pub num_misses: u32,
    pub miss_ibl_samples: u32,
    pub trace_ms: f32,
    pub shade_ms: f32,
    pub fallback_ms: f32,
}
```

Add a helper:

```rust
impl SsrStats {
    pub fn new() -> Self { ...zeros... }

    pub fn hit_rate(&self) -> f32 { 
        if self.num_rays == 0 { 0.0 } else { self.num_hits as f32 / self.num_rays as f32 }
    }
    pub fn avg_steps(&self) -> f32 {
        if self.num_hits == 0 { 0.0 } else { self.total_steps as f32 / self.num_hits as f32 }
    }
    pub fn miss_ibl_ratio(&self) -> f32 {
        if self.num_misses == 0 { 0.0 } else { self.miss_ibl_samples as f32 / self.num_misses as f32 }
    }
    pub fn perf_ms(&self) -> f32 {
        self.trace_ms + self.shade_ms + self.fallback_ms
    }
}
```

1.2. Extend your existing `run_ssr_pipeline(...)` (or equivalent driver in `src/passes/ssr.rs`) to:

* Accept a mutable `SsrStats` reference.
* Fill it with **real values**:

Implementation requirements:

* **Ray counts & steps:**

  * In `trace.wgsl`, you already have per-pixel hit/miss and step count information (or can add it easily).
  * Emit this to a small integer texture or storage buffer (`r32uint` or struct of `u32`s).
  * After the SSR pass, in Rust, map that buffer once and:

    * Count `num_rays` = width * height of the SSR target.
    * For each pixel:

      * If ray hit → `stats.num_hits += 1`, `stats.total_steps += steps`.
      * If ray missed → `stats.num_misses += 1`.

* **Miss IBL ratio:**

  * In `fallback_env.wgsl`, when you actually sample IBL for a miss, increment a `miss_ibl_samples` counter in a reduction buffer.
  * Read this back and assign to `stats.miss_ibl_samples`.

* **Timing (ms):**

  * Around each of the three passes (trace, shade, fallback) in Rust, take timestamps using your existing profiling helper (if there is one; otherwise `std::time::Instant` on CPU is acceptable).
  * Set:

    * `stats.trace_ms`
    * `stats.shade_ms`
    * `stats.fallback_ms`

**Constraints:**

* Do not perform per-pixel loops in hot paths every frame for the interactive viewer. For P5, you can gate the reduction on a “P5 capture” flag, or run it only for the headless harness.
* All of `hit_rate`, `avg_steps`, `miss_ibl_ratio`, and `perf_ms` **must be > 0** for the M2 glossy test scene.

---

### 2. Fix the stripe-contrast analysis to produce 9 valid values

Currently `ssr_stripe_contrast` looks like: `[0,0,0,0.99,0,0,0,0,0]`.
This is wrong; only one band is being measured.

**Target behavior for M2:**

* `ssr_stripe_contrast` is a `Vec<f32>` of length **9**.
* Each entry corresponds to one sphere (or cube band) from lowest roughness (index 0) to highest roughness (index 8).
* All entries must be **> 0**.
* The sequence should be **strictly monotonically decreasing** (or at least non-increasing) as roughness increases.

2.1. In `src/p5/ssr.rs` (or wherever `analyze_stripe_contrast` lives):

* Make the function signature explicit:

```rust
pub fn analyze_stripe_contrast(
    reference_path: &Path,
    ssr_path: &Path,
    out_contrast: &mut [f32; 9],
) -> Result<(), anyhow::Error>
```

2.2. Implement the analysis **using image ROIs**:

* Load both `p5_ssr_glossy_reference.png` and `p5_ssr_glossy_spheres.png` into `image::RgbaImage`.
* Derive width/height; sphere row is horizontally centered and at a known vertical band.
* Compute 9 equal-width ROIs along the stripe / reflection band:

```rust
let band_y0 = (0.55 * height as f32) as u32; // example; adjust if needed
let band_y1 = (0.65 * height as f32) as u32;
for i in 0..9 {
    let x0 = (i as f32 / 9.0 * width as f32) as u32;
    let x1 = ((i+1) as f32 / 9.0 * width as f32) as u32;
    // clamp, avoid zero-width
}
```

* For each ROI:

  * Compute mean **luminance** for the reference (`L_ref`) and SSR (`L_ssr`), using `0.2126 R + 0.7152 G + 0.0722 B`.
  * Define contrast as:

```rust
let eps = 1e-4;
contrast[i] = ((L_ssr - L_ref).abs()) / (L_ref.abs() + eps);
```

* Store into `out_contrast[i]`.

2.3. Add **sanity checks**:

After filling `out_contrast`:

* Assert all values are finite and > 0.
* Check monotonicity:

```rust
let mut monotonic = true;
for i in 1..9 {
    if out_contrast[i] > out_contrast[i - 1] + 1e-3 {
        monotonic = false;
        break;
    }
}
```

Return an error or flag in meta if this fails.

---

### 3. Populate `p5_meta.json` correctly and drive `ssr_status`

In `src/p5/meta.rs` where you write SSR fields:

3.1. Replace the zeroed `ssr` block with real stats:

```rust
pub struct SsrMeta {
    pub hit_rate: f32,
    pub avg_steps: f32,
    pub miss_ibl_ratio: f32,
    pub perf_ms: f32,
    pub max_delta_e_miss: f32,
    pub min_rgb_miss: f32,
}

pub fn write_p5_meta(..., ssr_stats: Option<&SsrStats>, stripe_contrast: Option<&[f32; 9]>, ...) {
    // ...
    if let Some(stats) = ssr_stats {
        meta["ssr"]["hit_rate"] = json!(stats.hit_rate());
        meta["ssr"]["avg_steps"] = json!(stats.avg_steps());
        meta["ssr"]["miss_ibl_ratio"] = json!(stats.miss_ibl_ratio());
        meta["ssr"]["perf_ms"] = json!(stats.perf_ms());
    } else {
        // keep 0.0 but set status to UNINITIALIZED
    }
    if let Some(contrast) = stripe_contrast {
        meta["ssr_stripe_contrast"] = json!(contrast);
    }
    // write ssr_edge_streaks elsewhere (can stay 0 for now)
}
```

3.2. Set `ssr_status` based on actual data:

Define:

```rust
fn classify_ssr_status(
    stats: &SsrStats,
    contrast: &[f32; 9],
) -> &'static str {
    if stats.num_rays == 0 {
        "SSR_UNINITIALIZED"
    } else if stats.hit_rate() <= 0.0 || stats.perf_ms() <= 0.0 {
        "SSR_STATS_INVALID"
    } else if !is_monotonic_decreasing(contrast) {
        "SSR_STRIPE_INVALID"
    } else {
        "SHADE_READY"
    }
}
```

* Call this and write `meta["ssr_status"]` accordingly.
* Do **not** hard-code `"SHADE_READY"` any more.

---

### 4. Hook thickness ablation into meta (lightweight)

In `examples/p5_ssr_thickness_ablation.rs` and `write_p5_meta`:

* Add a small meta section:

```rust
meta["ssr_thickness_test"] = json!({
    "enabled": true,
    "thickness_off_on_path": "reports/p5/p5_ssr_thickness_ablation.png"
});
```

* No need for detailed undershoot metrics at M2, but `enabled: true` ensures we can verify the ablation ran.

---

### 5. Validation you must make pass

After changes:

1. Run:

```bash
cargo run --release --example p5_ssr_glossy
```

Check `reports/p5/p5_meta.json`:

* `meta["ssr"]["hit_rate"]` ∈ (0.01, 1.0).
* `meta["ssr"]["avg_steps"]` > 0.
* `meta["ssr"]["perf_ms"]` > 0.
* `meta["ssr_stripe_contrast"]` has length 9, all values > 0, and is monotonic non-increasing.
* `meta["ssr_status"] == "SHADE_READY"`.

2. Run:

```bash
cargo run --release --example p5_ssr_thickness_ablation
```

* `reports/p5/p5_ssr_thickness_ablation.png` is updated.
* `p5_meta.json` has `"ssr_thickness_test": { "enabled": true, ... }`.

Do not change SSGI behavior or any existing P5 SSGI metrics; only **add / fix** the SSR-specific pieces described above.

