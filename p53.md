**PROMPT FOR CODEX – M2 SSR SHADING + ANALYTICS FIX**

You are ChatGPT Codex High Reasoning working on the `p5` SSR milestones for a Rust + WGSL renderer.

Current state (important):

* SSR tracing + shading + env fallback are implemented and wired through `run_ssr_pipeline` (or equivalent) and the glossy nine-sphere scene renders to:

  * `reports/p5/p5_ssr_glossy_reference.png`  (SSR off)
  * `reports/p5/p5_ssr_glossy_spheres.png`    (SSR on)
* `p5_meta.json` already contains an `ssr` section with:

  * `hit_rate`, `avg_steps`, `miss_ibl_ratio`, `perf_ms`
  * `stripe_contrast`: currently **[0,0,0,0,0,0,0,0,0]**
  * `edge_streaks.num_streaks_gt1px`
  * `status`: currently a **FAIL** message complaining about tiny ref/SSR difference and near-zero stripe contrast.
* There is a thickness ablation harness that writes:

  * `reports/p5/p5_ssr_thickness_ablation.png`
    but the before/after halves look almost identical and do not clearly show undershoot vs fixed reflections.

Your task is to **complete Milestone M2** by fixing the SSR diagnostics and thickness visualization, without regressing M0/M1, and making the meta pass its own checks.

---

### 1. Fix stripe-contrast measurement for the glossy spheres

Goals:

* `ssr.stripe_contrast` must be a 9-element array, one value per sphere from roughness `r=0.1` (left) to `r=0.9` (right).
* Each value measures the contrast of the reflected bright stripe on that sphere.
* After a correct SSR render, the array should:

  * Be **strictly monotonically decreasing** as roughness increases (within a small epsilon).
  * Have a significant difference between the first and last spheres.

Concrete steps:

1. **Find the existing analysis helpers** (names may differ slightly):

   * `analyze_stripe_contrast(...)`
   * `mean_abs_diff(...)`
   * The code that fills `ssr.stripe_contrast` and builds `ssr.status` in `src/p5/meta.rs` or nearby.
2. **Verify which buffer is sampled** for the analysis:

   * Ensure you are reading the **final lit + SSR image** that corresponds to `p5_ssr_glossy_spheres.png`, not some pre-SSR or pre-tonemap buffer.
   * If necessary, plumb a CPU-visible copy of the resolved color buffer (the same one used to write the PNG) into the analysis path.
3. **Define robust ROIs per sphere**:

   * Use known scene layout from `reports/p5/p5_ssr_scene.json` or the procedural scene builder in `src/p5/ssr.rs` (positions, radius, camera).
   * Project each sphere’s center into screen space and define a small rectangular band on the **highlighted hemisphere** where the horizontal stripe reflection appears.
   * Alternatively, hard-code normalized viewport rectangles based on the current composition, but keep them **clearly separated per sphere** and documented.
4. **Compute stripe contrast per sphere**:

   * Within each sphere ROI:

     * Convert RGB → luminance (e.g. `L = 0.2126*R + 0.7152*G + 0.0722*B`).
     * Compute a simple stripe contrast metric, for example Michelson contrast:

       * `C = (L_max - L_min) / max(L_max + L_min, 1e-4)`
       * or std-dev / mean as long as it correlates with visibility.
   * Store these nine values in `ssr.stripe_contrast[0..8]` in **left-to-right sphere order**.
5. **Update SSR status logic**:

   * After computing `stripe_contrast`, enforce:

     * `stripe_contrast.len() == 9`
     * Strict monotonicity: `stripe_contrast[i] > stripe_contrast[i+1] - eps` with `eps ≈ 0.01`.
     * Low vs high separation: `stripe_contrast[0] - stripe_contrast[8] >= 0.2` (or the same numeric threshold used in the current failure message).
   * Only if all checks pass, set:

     * `ssr.status = "SHADE_READY"`
   * If any check fails, keep a descriptive `FAIL: ...` message as now, but make sure it **reflects the actual numbers** being seen (no more “all near-zero” once the values are non-zero).

Acceptance for this part:

* After `cargo run --release --example p5_ssr_glossy`, `p5_meta.json` must show:

  * `ssr.stripe_contrast` ≈ 9 descending values.
  * `ssr.status == "SHADE_READY"`.
* A quick numerical sanity check should show:

  * `stripe_contrast[0] > stripe_contrast[8]` by at least ~0.2.
  * No zeros unless the sphere is genuinely blacked out.

---

### 2. Ensure SSR actually changes the glossy spheres vs reference

Right now the meta complains about tiny difference between reference and SSR images.

1. Inspect the code path that produces:

   * `p5_ssr_glossy_reference.png` (SSR off).
   * `p5_ssr_glossy_spheres.png`    (SSR on).
2. Ensure the SSR path:

   * Uses the **reflected radiance** from the SSR trace, weighted by Fresnel Schlick and roughness, and **adds it** to or replaces the specular term, not just re-using the same IBL/light data as the reference.
   * Is actually enabled for the glossy spheres in the scene (correct material flags, roughness, metallic, etc.).
3. In the capture pipeline:

   * Confirm that the SSR compositing pass runs only for the “SSR on” frame, and **not** for the reference frame.
   * Double-check that the same camera / exposure / tonemap settings are used for both frames.

Update the meta logic (where it already computes a mean absolute difference) so that:

* If the reference vs SSR difference is below a tiny epsilon (e.g. `< 1e-3`), that contributes to a `FAIL` reason (as it does now).
* Once SSR is wired correctly, this condition should no longer trigger.

Acceptance:

* With SSR enabled, the reflected stripe on the spheres should visually tighten/brighten relative to the reference image.
* The mean difference between `p5_ssr_glossy_reference.png` and `p5_ssr_glossy_spheres.png` should be **clearly non-zero**, and the meta check must no longer fail on “difference too small”.

---

### 3. Make the thickness ablation image clearly show the effect

The current `reports/p5/p5_ssr_thickness_ablation.png` is too subtle: the “thickness off” and “thickness on” halves look almost identical.

Modify the thickness harness and/or scene so that:

1. The test reliably produces **undershoot / overreach artifacts** when thickness is disabled:

   * E.g. a bright horizontal stripe behind the checker cube, so SSR rays can “hit” geometry behind the visible surface unless clamped by thickness.
2. With `--ssr-thickness = 0` (or equivalent “off” mode):

   * The left half of the ablation image should show clear **light leaks** / extensions of the stripe under or through the cube.
3. With a reasonable non-zero thickness:

   * The right half should show those artifacts **visibly reduced or gone**.

Implementation details:

* Keep using `examples/p5_ssr_thickness_ablation.rs` and whatever viewer command already exists, but:

  * Make sure the off/on variants really toggle the thickness parameter fed into `src/passes/ssr.rs`.
  * Compose the final PNG as `[thickness_off | thickness_on]` (side-by-side) exactly as the milestone spec expects.

Acceptance:

* A human looking at `p5_ssr_thickness_ablation.png` should immediately see “wrong” vs “fixed” behavior.
* If there is any meta attached to this capture, it should at least confirm that thickness is toggled and SSR is active in both halves.

---

### 4. Don’t regress earlier milestones

While making these changes, keep these invariants:

* M0 harness behavior is unchanged: you can still run the headless P5 harness and get valid PNG + meta.
* M1 trace mask (`p5_ssr_trace_mask.png`) continues to render, and any debug buffers used for ROI selection stay off in the final P5 glossy / thickness PNGs.
* No changes to non-SSR passes (SSAO/SSGI) beyond what’s required to keep the build compiling.

When you’re done, run:

* `cargo run --release --example p5_ssr_glossy`
* `cargo run --release --example p5_ssr_thickness_ablation`

and ensure:

* Both commands complete without errors.
* All PNGs are regenerated.
* `p5_meta.json.ssr.status == "SHADE_READY"` and the stripe contrast + difference checks are satisfied.

---

That’s the full delta needed to bring M2 to a **fully passing** state.
