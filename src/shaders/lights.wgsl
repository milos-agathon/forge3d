// src/shaders/lights.wgsl
// Light GPU buffer layout and sampling helpers
// Exists to expose multi-light data/sampling to shared lighting shaders
// RELEVANT FILES: src/lighting/types.rs, src/lighting/light_buffer.rs, src/shaders/lighting.wgsl, python/forge3d/config.py

const PI: f32 = 3.14159265359;

// Light types (matches Rust LightType enum)
const LIGHT_DIRECTIONAL: u32 = 0u;
const LIGHT_POINT: u32 = 1u;
const LIGHT_SPOT: u32 = 2u;
const LIGHT_ENVIRONMENT: u32 = 3u;
const LIGHT_AREA_RECT: u32 = 4u;
const LIGHT_AREA_DISK: u32 = 5u;
const LIGHT_AREA_SPHERE: u32 = 6u;

// Layout matches Rust src/lighting/types.rs::Light (80 bytes, 5 vec4s)
// CRITICAL: Field order must exactly match for std430 SSBO upload
struct LightGPU {
    // Vec4 #1: type, intensity, range, env_texture_index
    type_: u32,
    intensity: f32,
    range: f32,
    env_texture_index: u32,

    // Vec4 #2: color (RGB + padding)
    color: vec3<f32>,
    _pad1: f32,

    // Vec4 #3: position in world space
    pos_ws: vec3<f32>,
    _pad2: f32,

    // Vec4 #4: direction in world space
    dir_ws: vec3<f32>,
    _pad3: f32,

    // Vec4 #5: cone cosines + area half-extents
    cone_cos: vec2<f32>,
    area_half: vec2<f32>,
};

// Light metadata uniform (uploaded per-frame by LightBuffer)
// P1-03: Contains R2 sequence seeds for TAA-friendly light sampling
struct LightMetadata {
    count: u32,           // Number of active lights
    frame_index: u32,     // Monotonic frame counter (lower 32 bits)
    seed_bits_x: u32,     // R2 seed X component (f32 encoded as u32 bits)
    seed_bits_y: u32,     // R2 seed Y component (f32 encoded as u32 bits)
};

@group(0) @binding(3) var<storage, read> lights: array<LightGPU>;
@group(0) @binding(4) var<uniform> lightMeta: LightMetadata;

// P1-05: Environment lighting parameters (stub for P4 IBL)
// Currently initialized to zeros; full IBL importance sampling deferred to P4.
// Future fields may include:
//   - .x: environment intensity multiplier
//   - .y: environment rotation (degrees)
//   - .z: environment exposure
//   - .w: unused/reserved
@group(0) @binding(5) var<uniform> environmentParams: vec4<f32>;

fn light_count() -> u32 {
    return lightMeta.count;
}

// Retrieve per-frame R2 sequence seed for temporal light sampling (P1-03)
//
// Returns a 2D seed in [0, 1] range generated by the R2 (Roberts) low-discrepancy
// sequence on the CPU. Seeds vary deterministically each frame to support TAA:
// - Frame N: unique seed based on frame counter
// - Frame N+1: different seed, avoiding temporal aliasing
//
// Generated in Rust: src/lighting/light_buffer.rs::next_frame()
//   self.sequence_seed = r2_sample(self.frame_counter);
//   count_data = [count, frame_index, seed[0].to_bits(), seed[1].to_bits()];
//
// Usage for stochastic light sampling:
//   let base_seed = light_sequence_seed();
//   let pixel_jitter = fract(base_seed + vec2<f32>(pixel_coords));
//   let light_sample = sample_point(light_idx, pixel_jitter);
//
// This approach ensures temporally stable noise that TAA can accumulate effectively.
fn light_sequence_seed() -> vec2<f32> {
    return vec2<f32>(
        bitcast<f32>(lightMeta.seed_bits_x),
        bitcast<f32>(lightMeta.seed_bits_y)
    );
}

// P1-04: Light sampling helper functions
// These functions generate sample directions for different light types.
// All sampling uses Xi ∈ [0,1]² from R2 sequences or other low-discrepancy samplers.

// Sample directional light (infinite distance, constant direction)
// Returns the incident light direction (pointing from surface toward light source)
// 
// Parameters:
//   i: Light index in the lights array
// Returns:
//   Normalized direction vector (world space)
fn sample_directional(i: u32) -> vec3<f32> {
    let light = lights[i];
    return normalize(-light.dir_ws);
}

// Sample point light with uniform spherical distribution
// Generates directions uniformly distributed over the unit sphere.
// 
// Parameters:
//   i: Light index in the lights array
//   Xi: 2D random sample in [0,1]²
// Returns:
//   Normalized direction vector on unit sphere
fn sample_point(i: u32, Xi: vec2<f32>) -> vec3<f32> {
    let u = Xi.x;
    let v = Xi.y;
    let phi = 2.0 * PI * u;
    let cos_theta = 1.0 - 2.0 * v;
    let sin_theta = sqrt(max(0.0, 1.0 - cos_theta * cos_theta));
    return vec3<f32>(
        sin_theta * cos(phi),
        sin_theta * sin(phi),
        cos_theta
    );
}

// Sample spot light within cone frustum
// Generates directions within the spot cone defined by inner/outer cosines.
// Uses robust basis construction with fallback for near-vertical directions.
// 
// Parameters:
//   i: Light index in the lights array
//   Xi: 2D random sample in [0,1]²
// Returns:
//   Normalized direction vector within cone (world space)
fn sample_spot(i: u32, Xi: vec2<f32>) -> vec3<f32> {
    let light = lights[i];
    let inner_cos = light.cone_cos.x;
    let outer_cos = light.cone_cos.y;
    let u = Xi.x;
    let v = Xi.y;
    let cos_theta = mix(outer_cos, inner_cos, u);
    let sin_theta = sqrt(max(0.0, 1.0 - cos_theta * cos_theta));
    let phi = 2.0 * PI * v;
    let local_dir = vec3<f32>(
        sin_theta * cos(phi),
        sin_theta * sin(phi),
        cos_theta
    );
    // Build orthonormal basis from light direction
    // Note: Assumes up=(0,1,0) but spot direction can point anywhere
    let forward = normalize(light.dir_ws);
    let up = vec3<f32>(0.0, 1.0, 0.0);
    let right = normalize(cross(up, forward));
    let ortho_up = cross(forward, right);
    return normalize(
        local_dir.x * right +
        local_dir.y * ortho_up +
        local_dir.z * forward
    );
}

// Sample rectangular area light
// Generates uniformly distributed points on a rectangular surface.
// Uses robust basis construction with fallback for near-vertical normals (|ny| > 0.99).
// 
// Parameters:
//   i: Light index in the lights array
//   Xi: 2D random sample in [0,1]²
// Returns:
//   Direction from light center to sampled point (world space)
fn sample_area_rect(i: u32, Xi: vec2<f32>) -> vec3<f32> {
    let light = lights[i];
    let half_width = light.area_half.x;
    let half_height = light.area_half.y;
    let local = vec3<f32>(
        mix(-half_width, half_width, Xi.x),
        0.0,
        mix(-half_height, half_height, Xi.y)
    );
    let normal = normalize(light.dir_ws);
    // Robust basis construction: fallback to X-axis if normal near-vertical
    var up = vec3<f32>(0.0, 1.0, 0.0);
    if (abs(normal.y) > 0.99) {
        up = vec3<f32>(1.0, 0.0, 0.0);
    }
    let tangent = normalize(cross(up, normal));
    let bitangent = cross(normal, tangent);
    let world_pos = light.pos_ws + tangent * local.x + bitangent * local.z;
    return normalize(world_pos - light.pos_ws);
}

// Sample disk-shaped area light
// Generates uniformly distributed points on a circular disk.
// Uses concentric disk mapping (sqrt for radius) to maintain uniform density.
// Uses robust basis construction with fallback for near-vertical normals.
// 
// Parameters:
//   i: Light index in the lights array
//   Xi: 2D random sample in [0,1]²
// Returns:
//   Direction from light center to sampled point (world space)
fn sample_area_disk(i: u32, Xi: vec2<f32>) -> vec3<f32> {
    let light = lights[i];
    let radius = light.area_half.x;
    let r = radius * sqrt(Xi.x);
    let theta = 2.0 * PI * Xi.y;
    let local = vec3<f32>(r * cos(theta), 0.0, r * sin(theta));
    let normal = normalize(light.dir_ws);
    // Robust basis construction: fallback to X-axis if normal near-vertical
    var up = vec3<f32>(0.0, 1.0, 0.0);
    if (abs(normal.y) > 0.99) {
        up = vec3<f32>(1.0, 0.0, 0.0);
    }
    let tangent = normalize(cross(up, normal));
    let bitangent = cross(normal, tangent);
    let world_pos = light.pos_ws + tangent * local.x + bitangent * local.z;
    return normalize(world_pos - light.pos_ws);
}

// Sample spherical area light
// Currently delegates to point light sampling (uniform sphere distribution).
// Future: Could implement solid angle sampling from a specific view point.
// 
// Parameters:
//   i: Light index in the lights array
//   Xi: 2D random sample in [0,1]²
// Returns:
//   Normalized direction vector on unit sphere
fn sample_area_sphere(i: u32, Xi: vec2<f32>) -> vec3<f32> {
    let light = lights[i];
    return sample_point(i, Xi);
}

// Sample environment light (lat-long mapping)
// Placeholder for P1; full IBL importance sampling deferred to P4.
// Maps uniform Xi to spherical coordinates using simple lat-long parameterization.
// 
// Parameters:
//   Xi: 2D random sample in [0,1]²
// Returns:
//   Normalized direction vector (world space)
// 
// Note: This is a uniform distribution over the sphere. P4 will add importance
// sampling based on environment map luminance for better convergence.
fn sample_environment(Xi: vec2<f32>) -> vec3<f32> {
    // Placeholder lat-long mapping
    let phi = 2.0 * PI * Xi.x;
    let cos_theta = 1.0 - 2.0 * Xi.y;
    let sin_theta = sqrt(max(0.0, 1.0 - cos_theta * cos_theta));
    return vec3<f32>(
        sin_theta * cos(phi),
        cos_theta,
        sin_theta * sin(phi)
    );
}
