<task id="ws-A10-auto" version="1.0">
  <title>Workstream A · Task A10 — Implement per roadmap2.csv (derive deliverables → code/tests/docs)</title>

  <role>
    You are OpenAI Codex CLI in <b>Verification → Implementation Mode</b>, acting as a senior graphics/runtime engineer.
    Stack: WebGPU/wgpu + WGSL, Rust, Python ≥3.8 (PyO3/maturin abi3), CMake ≥3.24, VMA, Sphinx.
    Project: forge3d — Rust backend + Python frontend for interactive/offline 3D visualization.
  </role>

  <switches>
    <WRITE_CHANGES>true</WRITE_CHANGES>
    <USE_TESTS>true</USE_TESTS>
    <ENSURE_CI>true</ENSURE_CI>
  </switches>

  <constraints>
    <platforms>win_amd64, linux_x86_64, macos_universal2</platforms>
    <gpuBudget>≤ 512 MiB host-visible heap</gpuBudget>
    <safety>
      - Make only the minimal changes needed to satisfy the A10 row’s Deliverables and Acceptance Criteria.
      - Never delete custom user code; prefer adding .gitignore entries for generated artifacts.
      - If a tool is missing, mark the step SKIPPED with the exact command to run locally.
      - If the A10 row is missing/ambiguous, reply <b>UNCERTAIN</b> listing the exact headers/rows/fields needed, then STOP with no edits.
    </safety>
    <exclusions>.git, dist, build, .venv, venv, node_modules, __pycache__, *.png, *.jpg, *.pdf, *.whl, *.zip, *.tar.gz, out, diag_out</exclusions>
  </constraints>

  <inputs>
    <repoRoot>./</repoRoot>
    <roadmapPath>./roadmap2.csv</roadmapPath>
    <workstreamSelector>
      <![CDATA[
      Workstream ID: A
      Task ID: A10
      ]]>
    </workstreamSelector>
  </inputs>

  <!-- 1) Verify A10 exists and extract Title/Deliverables/Acceptance -->
  <prechecks>
    <command>
      <![CDATA[
python - <<'PY'
import csv, codecs, sys, json
row=None
try:
  with codecs.open("roadmap2.csv","r","utf-8-sig") as f:
    rdr=csv.DictReader(f)
    for r in rdr:
      if (r.get("Workstream ID","").strip().lower()=="a" and
          (r.get("Task ID","").strip().lower()=="a10" or "a10" in (r.get("Task Title","") or "").strip().lower())):
        row=r; break
except FileNotFoundError:
  print("UNCERTAIN: roadmap2.csv not found", file=sys.stderr); sys.exit(2)
if not row:
  print("UNCERTAIN: A10 not found in roadmap2.csv (Workstream A). Provide the exact row with headers.", file=sys.stderr); sys.exit(3)

meta={
  "Title": (row.get("Task Title","") or "").strip(),
  "Rationale": (row.get("Rationale","") or "").strip(),
  "Deliverables": (row.get("Deliverables","") or "").strip(),
  "Acceptance": (row.get("Acceptance Criteria","") or "").strip(),
  "Priority": (row.get("Priority","") or "").strip(),
  "Phase": (row.get("Phase","") or "").strip(),
  "Missing": (row.get("Missing Features","") or "").strip(),
  "Dependencies": (row.get("Dependencies","") or "").strip(),
  "Risks": (row.get("Risks/Mitigations","") or "").strip()
}
print("WORKSTREAM_TASK_FOUND:A10")
print("A10_META:"+json.dumps(meta, ensure_ascii=False))
PY
      ]]>
    </command>
  </prechecks>

  <design>
    <mappingRules>
      <![CDATA[
Derive concrete artifacts from A10 “Deliverables” using these keyword→path rules (use exact filenames in CSV if present):
- "WGSL", "compute", "shader", "kernel" → src/shaders/<feature>.wgsl
- "BVH", "accel", "traversal" → src/accel/*.rs, src/path_tracing/accel.rs (+ WGSL hooks)
- "intersection", "ray-triangle", "ray-sphere" → src/path_tracing/intersect.rs and/or src/shaders/pt_intersect_*.wgsl
- "sampling", "MIS", "lights", "pdf" → src/lighting/*.rs, src/shaders/lighting_*.wgsl, python/forge3d/lighting.py
- "materials", "BSDF", "PBR", "GGX", "BRDF" → src/pbr/*.rs, python/forge3d/pbr.py, shaders/pbr_*.wgsl
- "camera", "DOF", "thin lens", "motion blur", "jitter", "TAA" → src/camera/*.rs, python/forge3d/camera.py, shaders/camera_*.wgsl
- "textures", "image", "mipmap", "sampler" → src/textures/*.rs, python/forge3d/textures.py, shaders/texture_*.wgsl
- "IBL", "environment", "sun-sky", "HDR" → src/lighting/ibl.rs, shaders/ibl_*.wgsl, python/forge3d/ibl.py
- "instancing", "transforms", "scene graph" → src/scene/*.rs, python/forge3d/scene.py
- "volumes", "media", "phase", "sigma" → src/volumes/*.rs, shaders/volume_*.wgsl, python/forge3d/volumes.py
- "tonemap", "ACES", "Reinhard", "exposure" → src/post/tonemap.rs, src/shaders/tonemap.wgsl, python bridge
- "Python API" → python/forge3d/<feature>.py (public class/functions + type hints)
- "docs" → README.md section and docs/api/<feature>.md (if Sphinx present)
- "tests" → tests/<feature>_*.rs or tests/test_<feature>*.py (GPU tests @skip if no adapter)
- "examples" → examples/<feature>_*.py (write images to out/; ensure .gitignore ignores out/)
If Deliverables specify explicit filenames, use those verbatim instead of heuristics.
      ]]>
    </mappingRules>
    <acceptanceStrategy>
      <![CDATA[
For each bullet/line in A10 Deliverables:
  1) Map it to concrete files/symbols with the rules above.
  2) Implement the smallest viable code to satisfy A10 “Acceptance Criteria”.
  3) If a deliverable is ambiguous, mark UNCERTAIN with the exact text and the minimal clarification needed.
      ]]>
    </acceptanceStrategy>
  </design>

  <acceptanceCriteria>
    <ac id="AC-0">A10 row is present; meta printed as A10_META JSON.</ac>
    <ac id="AC-1">Every concrete deliverable item from A10’s Deliverables cell exists as code/docs/tests artifacts with appropriate header/inline docs (bind groups for WGSL, public APIs for Python/Rust).</ac>
    <ac id="AC-2">Python public API exposes the functions/classes required by A10’s Acceptance Criteria (row text), with type hints and deterministic behavior notes where relevant.</ac>
    <ac id="AC-3">Unit/integration tests exist for all implemented deliverables; GPU-dependent tests are skipped when no compatible adapter is available.</ac>
    <ac id="AC-4">Docs updated: README + docs/api/<feature>.md (if Sphinx present) clearly describing usage and limitations; examples added if requested by A10.</ac>
    <ac id="AC-5">Validation run passes: fmt, clippy -D warnings, cargo test, pytest, sphinx-build (if docs), maturin build; CI ensured if missing.</ac>
  </acceptanceCriteria>

  <changes>
    <createOrModify>
      <!-- Actual files depend on A10 deliverables; these directories are typical targets -->
      <file path="src/shaders/" kind="modify-or-new"/>
      <file path="src/path_tracing/" kind="modify-or-new"/>
      <file path="src/accel/" kind="modify-or-new"/>
      <file path="src/lighting/" kind="modify-or-new"/>
      <file path="src/pbr/" kind="modify-or-new"/>
      <file path="src/camera/" kind="modify-or-new"/>
      <file path="src/textures/" kind="modify-or-new"/>
      <file path="src/scene/" kind="modify-or-new-optional"/>
      <file path="src/volumes/" kind="modify-or-new-optional"/>
      <file path="python/forge3d/" kind="modify-or-new"/>
      <file path="tests/" kind="modify-or-new"/>
      <file path="examples/" kind="modify-or-new-optional"/>
      <file path="README.md" kind="modify-append"/>
      <file path="docs/api/" kind="modify-or-new-optional"/>
      <file path=".gitignore" kind="modify-append"/>
    </createOrModify>
  </changes>

  <tests>
    <templates>
      <![CDATA[
- GPU feature tests (pytest): skip if no adapter; assert shapes/dtypes; deterministic behavior for frames=1 with fixed seed; tolerance checks vs CPU where defined.
- Rust unit tests: validate struct packing/layout, math helpers, error paths (no panics across FFI).
- Docs build test: sphinx-build succeeds (or SKIPPED if docs absent).
- Example smoke test (optional): script runs headless and writes to out/ (gitignored).
      ]]>
    </templates>
  </tests>

  <!-- EXACTLY INCLUDE THESE STEPS -->
  <plan>
    5) Implementation (Write mode only if &lt;WRITE_CHANGES&gt;true&lt;/WRITE_CHANGES&gt;)
       - Create branch: <code>git checkout -b ws-&lt;ID-or-slug&gt;-implementation</code>
       - For each task in deterministic order (by Priority then Task ID):
         * Apply minimal changes.
         * Add/update tests when <USE_TESTS>true</USE_TESTS>.
         * Update docs (Sphinx/README) and example scripts if referenced by AC.
         * Update CI if <ENSURE_CI>true</ENSURE_CI> and AC requires.
         * Keep one commit per task: <code>git commit -am "WS&lt;ID&gt; &lt;TaskID&gt;: &lt;short summary&gt;"</code>
       - Maintain safety: never delete custom user code; only remove generated artifacts (.pyd/.so, build/ etc.) when explicitly required by AC; otherwise add .gitignore entries.

    6) Validation Run
       - Commands (skip gracefully if tool missing; record SKIPPED):
         * <code>cargo fmt -- --check</code>
         * <code>cargo clippy --all-targets --all-features -D warnings</code>
         * <code>cargo test -q</code>
         * <code>pytest -q</code> (when <USE_TESTS>true</USE_TESTS>)
         * <code>sphinx-build -b html docs _build/html</code>
         * <code>maturin build --release</code>
         * <code>cmake -S . -B build && cmake --build build</code> (if CMake wrapper is part of AC)
       - Re-run the audit matrix; all tasks should now be <b>Present & Wired</b>.
       - If any still failing → fix or mark explicitly BLOCKED with reason.

    7) PR Preparation
       - Generate <b>PR_BODY.md</b> summarizing: scope, tasks addressed, evidence, risks/mitigations, and validation output.
       - Print final change summary: <code>git status -s</code>, <code>git log --oneline -n 50</code>.
  </plan>

  <execution>
    <steps>
      <step>Create feature branch: <code>git checkout -b ws-A10-implementation</code></step>
      <step>Parse A10_META (printed above) into bullet items (split by newlines/semicolons). Save mapping to <code>reports/a10_plan.json</code> (deliverable → files/symbols) using the mapping rules.</step>
      <step>For each mapped deliverable:
        <ul>
          <li>Implement minimal, correct code in WGSL/Rust/Python as indicated by the mapping rules and A10 Acceptance Criteria.</li>
          <li>Add/modify tests (Rust/Python) covering success paths and at least one failure/validation path.</li>
          <li>Update README and docs/api/&lt;feature&gt;.md (if Sphinx present) with usage, parameters, and limitations.</li>
          <li>If examples requested: add an example script in <code>examples/</code> writing outputs to <code>out/</code> (ensure .gitignore ignores it).</li>
        </ul>
      </step>
      <step>Append <code>.gitignore</code> entries for out/, diag_out/, and build artifacts if needed.</step>
      <step>Run the Validation Run commands; fix non-flaky failures; mark SKIPPED where tools are absent and record the exact command.</step>
      <step>Create <code>PR_BODY.md</code> summarizing A10 implementation with references to files/lines and validation results; print <code>git status -s</code> and <code>git log --oneline -n 50</code>.</step>
    </steps>
  </execution>

  <completion>
    <print>
      - reports/a10_plan.json
      - All created/modified source files per mapping (WGSL/Rust/Python)
      - tests/* for implemented features
      - examples/* (if requested by A10)
      - README.md (updated)
      - docs/api/* (if Sphinx present)
      - PR_BODY.md
    </print>
    <fallback>
      If A10 is not found or its Deliverables/Acceptance text is empty/ambiguous, respond <b>UNCERTAIN</b> listing the exact missing fields and STOP without changes.
    </fallback>
  </completion>
</task>
