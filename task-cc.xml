<task id="ws-A2-auto" version="1.0">
  <title>Workstream A · Task A2 — Implement per roadmap2.csv (auto-derive deliverables → code/tests/docs)</title>

  <role>
    You are OpenAI Codex CLI in <b>Verification → Implementation Mode</b>, acting as a senior graphics/runtime engineer.
    Stack: WebGPU/wgpu + WGSL, Rust, Python ≥3.8 (PyO3/maturin abi3), CMake ≥3.24, VMA, Sphinx.
    Project: forge3d — Rust backend + Python frontend for interactive/offline 3D visualization.
  </role>

  <switches>
    <WRITE_CHANGES>true</WRITE_CHANGES>
    <USE_TESTS>true</USE_TESTS>
    <ENSURE_CI>true</ENSURE_CI>
  </switches>

  <constraints>
    <platforms>win_amd64, linux_x86_64, macos_universal2</platforms>
    <gpuBudget>≤ 512 MiB host-visible heap</gpuBudget>
    <safety>
      - Minimal, additive changes guided strictly by roadmap2.csv A2 row; do not remove user code.
      - If a tool is missing, mark step SKIPPED with the exact command to run locally.
      - If A2 is ambiguous, reply <b>UNCERTAIN</b> with the precise missing fields/rows and STOP without changes.
    </safety>
    <exclusions>.git, dist, build, .venv, venv, node_modules, __pycache__, *.png, *.jpg, *.pdf, *.whl, *.zip, *.tar.gz, out, diag_out</exclusions>
  </constraints>

  <inputs>
    <repoRoot>./</repoRoot>
    <roadmapPath>./roadmap2.csv</roadmapPath>
    <workstreamSelector>
      <![CDATA[
      Workstream ID: A
      Task ID: A2
      ]]>
    </workstreamSelector>
  </inputs>

  <!-- 1) Verify A2 exists and extract Title/Deliverables/Acceptance -->
  <prechecks>
    <command>
      <![CDATA[
python - <<'PY'
import csv, codecs, sys, json, re
row=None
try:
  with codecs.open("roadmap2.csv","r","utf-8-sig") as f:
    rdr=csv.DictReader(f)
    for r in rdr:
      if (r.get("Workstream ID","").strip().lower()=="a" and
          (r.get("Task ID","").strip().lower()=="a2" or "a2" in (r.get("Task Title","") or "").strip().lower())):
        row=r; break
except FileNotFoundError:
  print("UNCERTAIN: roadmap2.csv not found", file=sys.stderr); sys.exit(2)
if not row:
  print("UNCERTAIN: A2 not found in roadmap2.csv (Workstream A). Provide exact row with headers.", file=sys.stderr); sys.exit(3)

meta={
  "Title": row.get("Task Title","").strip(),
  "Rationale": row.get("Rationale","").strip(),
  "Deliverables": row.get("Deliverables","").strip(),
  "Acceptance": row.get("Acceptance Criteria","").strip(),
  "Priority": row.get("Priority","").strip(),
  "Phase": row.get("Phase","").strip()
}
print("WORKSTREAM_TASK_FOUND:A2")
print("A2_META:"+json.dumps(meta, ensure_ascii=False))
PY
      ]]>
    </command>
  </prechecks>

  <!-- 2) Heuristic mapping rules turn Deliverables text into concrete artifacts -->
  <design>
    <mappingRules>
      <![CDATA[
Mapping keywords → files (prefix-rooted):
- "WGSL", "compute", "kernel", "shader" → src/shaders/<derived_name>.wgsl
- "BVH", "accel", "traversal" → src/accel/*.rs and/or src/path_tracing/accel.rs
- "intersection", "ray-triangle", "ray-sphere" → src/path_tracing/intersect.rs (or existing module), plus WGSL if GPU.
- "materials", "BSDF", "PBR", "BRDF" → src/pbr/*.rs, python/forge3d/pbr.py, shaders/pbr_*.wgsl
- "camera", "DOF", "thin lens" → src/camera/*.rs, python/forge3d/camera.py
- "HDR", "tonemap", "ACES", "Reinhard" → src/post/tonemap.rs, src/shaders/tonemap.wgsl, python bridge
- "IBL", "environment", "cubemap" → src/lighting/ibl.rs, src/shaders/ibl_*.wgsl
- "Python API" → python/forge3d/<feature>.py (public functions/classes + type hints)
- "docs" → README.md section and docs/api/<feature>.md (if Sphinx present)
- "tests" → tests/<feature>_*.rs or tests/test_<feature>*.py (GPU tests @skip if no adapter)
If Deliverables specify exact filenames, use those paths verbatim.
      ]]>
    </mappingRules>
    <acceptanceStrategy>
      <![CDATA[
For each bullet/line in the Deliverables cell:
  1) Infer feature kind by keywords; choose target file paths.
  2) Implement the smallest viable code for MVP that satisfies the Acceptance Criteria cell.
  3) If ambiguity remains (no keywords matched), mark UNCERTAIN with the exact deliverable text.
      ]]>
    </acceptanceStrategy>
  </design>

  <acceptanceCriteria>
    <ac id="AC-0">A2 row is present; meta printed as A2_META JSON.</ac>
    <ac id="AC-1">Every concrete deliverable item from A2’s Deliverables cell is implemented as code/docs/tests artifacts, with header/inline docs for bind groups and public APIs where applicable.</ac>
    <ac id="AC-2">Python public API exposes the functions/classes required by Acceptance Criteria (A2 row); type hints and deterministic behavior notes included.</ac>
    <ac id="AC-3">Unit/integration tests exist for all implemented deliverables; GPU-dependent tests are skipped when no compatible adapter is available.</ac>
    <ac id="AC-4">Docs updated: README + docs/api/<feature>.md (if Sphinx present) clearly describing usage and limitations.</ac>
    <ac id="AC-5">Validation run passes: fmt, clippy -D warnings, cargo test, pytest, sphinx-build (if docs), maturin build; CI ensured if missing.</ac>
  </acceptanceCriteria>

  <changes>
    <createOrModify>
      <!-- The actual files are derived from A2 deliverables; these are typical targets -->
      <file path="src/shaders/" kind="modify-or-new"/>
      <file path="src/path_tracing/" kind="modify-or-new"/>
      <file path="src/accel/" kind="modify-or-new"/>
      <file path="src/post/" kind="modify-or-new"/>
      <file path="src/lighting/" kind="modify-or-new"/>
      <file path="python/forge3d/" kind="modify-or-new"/>
      <file path="tests/" kind="modify-or-new"/>
      <file path="README.md" kind="modify-append"/>
      <file path="docs/api/" kind="modify-or-new-optional"/>
      <file path=".gitignore" kind="modify-append"/>
    </createOrModify>
  </changes>

  <tests>
    <templates>
      <![CDATA[
- GPU feature: create pytest with skip-if-no-adapter; assert shape/dtype, determinism for frames=1 with fixed seed.
- CPU feature: assert outputs match GPU within epsilon where defined; else assert contract (e.g., function raises on invalid input).
- Doc build: sphinx-build must succeed without warnings (or warnings logged & test passes if docs absent).
      ]]>
    </templates>
  </tests>

  <!-- EXACTLY INCLUDE THESE STEPS -->
  <plan>
    5) Implementation (Write mode only if &lt;WRITE_CHANGES&gt;true&lt;/WRITE_CHANGES&gt;)
       - Create branch: <code>git checkout -b ws-&lt;ID-or-slug&gt;-implementation</code>
       - For each task in deterministic order (by Priority then Task ID):
         * Apply minimal changes.
         * Add/update tests when <USE_TESTS>true</USE_TESTS>.
         * Update docs (Sphinx/README) and example scripts if referenced by AC.
         * Update CI if <ENSURE_CI>true</ENSURE_CI> and AC requires.
         * Keep one commit per task: <code>git commit -am "WS&lt;ID&gt; &lt;TaskID&gt;: &lt;short summary&gt;"</code>
       - Maintain safety: never delete custom user code; only remove generated artifacts (.pyd/.so, build/ etc.) when explicitly required by AC; otherwise add .gitignore entries.

    6) Validation Run
       - Commands (skip gracefully if tool missing; record SKIPPED):
         * <code>cargo fmt -- --check</code>
         * <code>cargo clippy --all-targets --all-features -D warnings</code>
         * <code>cargo test -q</code>
         * <code>pytest -q</code> (when <USE_TESTS>true</USE_TESTS>)
         * <code>sphinx-build -b html docs _build/html</code>
         * <code>maturin build --release</code>
         * <code>cmake -S . -B build && cmake --build build</code> (if CMake wrapper is part of AC)
       - Re-run the audit matrix; all tasks should now be <b>Present & Wired</b>.
       - If any still failing → fix or mark explicitly BLOCKED with reason.

    7) PR Preparation
       - Generate <b>PR_BODY.md</b> summarizing: scope, tasks addressed, evidence, risks/mitigations, and validation output.
       - Print final change summary: <code>git status -s</code>, <code>git log --oneline -n 50</code>.
  </plan>

  <execution>
    <steps>
      <step>Create feature branch: <code>git checkout -b ws-A2-implementation</code></step>
      <step>Parse A2_META (printed above) to list deliverable bullets; write a small <code>reports/a2_plan.json</code> mapping each bullet → target files via the mapping rules.</step>
      <step>For each mapped deliverable:
        <ul>
          <li>Implement minimal, correct code in WGSL/Rust/Python as indicated.</li>
          <li>Add or modify tests (Rust/Python) covering success path and a simple failure path.</li>
          <li>Update README and docs/api/&lt;feature&gt;.md (if Sphinx present) with usage and limitations.</li>
        </ul>
      </step>
      <step>Append <code>.gitignore</code> for out/, diag_out/, build artifacts if needed.</step>
      <step>Run the Validation Run commands; fix non-flaky failures; mark SKIPPED where tools are absent.</step>
      <step>Create <code>PR_BODY.md</code> summarizing A2 implementation with references to lines/files changed; print <code>git status -s</code> and <code>git log --oneline -n 50</code>.</step>
    </steps>
  </execution>

  <completion>
    <print>
      - reports/a2_plan.json
      - All created/modified source files per mapping (WGSL/Rust/Python)
      - tests/* for implemented features
      - README.md (updated)
      - docs/api/* (if Sphinx present)
      - PR_BODY.md
    </print>
    <fallback>
      If A2 is not found or the Deliverables cell is empty/ambiguous, respond <b>UNCERTAIN</b> listing the exact missing fields and STOP without changes.
    </fallback>
  </completion>
</task>
