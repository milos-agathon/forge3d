<task id="ws-A19-A25-batch" version="1.0">
  <title>Workstream A · Tasks A19–A25 — Implement per roadmap2.csv (derive deliverables → code/tests/docs; single branch, per-task commits)</title>

  <role>
    You are <b>Claude Code</b> in <b>Verification → Implementation Mode</b>, acting as a senior graphics/runtime engineer.
    Stack: WebGPU/wgpu + WGSL, Rust, Python ≥3.8 (PyO3/maturin abi3), CMake ≥3.24, VMA, Sphinx.
    Project: forge3d — Rust backend + Python frontend for interactive/offline 3D visualization (terrain, maps, graphs).
  </role>

  <switches>
    <WRITE_CHANGES>true</WRITE_CHANGES>
    <USE_TESTS>true</USE_TESTS>
    <ENSURE_CI>true</ENSURE_CI>
  </switches>

  <constraints>
    <platforms>win_amd64, linux_x86_64, macos_universal2</platforms>
    <gpuBudget>≤ 512 MiB host-visible heap</gpuBudget>
    <safety>
      - Minimal, additive changes to satisfy each task’s Deliverables and Acceptance Criteria (A19…A25).
      - Preserve existing public APIs unless a task explicitly calls for a breaking change; prefer opt-in flags/parameters.
      - Never delete custom user code; for generated artifacts prefer adding .gitignore entries instead of removing tracked files.
      - If a required tool is missing, mark the step SKIPPED with the exact command to run locally.
      - If any task row is missing/ambiguous, reply <b>UNCERTAIN</b> listing the exact headers/rows/fields needed, then STOP with no edits.
    </safety>
    <exclusions>.git, dist, build, .venv, venv, node_modules, __pycache__, *.png, *.jpg, *.pdf, *.whl, *.zip, *.tar.gz, out, diag_out</exclusions>
  </constraints>

  <inputs>
    <repoRoot>./</repoRoot>
    <roadmapPath>./roadmap2.csv</roadmapPath>
    <workstreamSelector>
      <![CDATA[
      Workstream ID: A
      Task IDs: A19, A20, A21, A22, A23, A24, A25
      ]]>
    </workstreamSelector>
  </inputs>

  <!-- Verify A19–A25 exist and extract Title/Deliverables/Acceptance for each -->
  <prechecks>
    <command>
      <![CDATA[
python - <<'PY'
import csv, codecs, sys, json
want=[f"a{i}" for i in range(19,26)]
found={}
missing=[]
try:
  with codecs.open("roadmap2.csv","r","utf-8-sig") as f:
    rdr=csv.DictReader(f)
    rows=list(rdr)
    for tid in want:
      row=None
      for r in rows:
        wid=(r.get("Workstream ID","") or "").strip().lower()
        rid=(r.get("Task ID","") or "").strip().lower()
        ttl=(r.get("Task Title","") or "").strip()
        if wid=="a" and (rid==tid or tid in ttl.lower()):
          row=r; break
      if not row:
        missing.append(tid.upper()); continue
      found[tid.upper()]={
        "Title": (row.get("Task Title","") or "").strip(),
        "Rationale": (row.get("Rationale","") or "").strip(),
        "Deliverables": (row.get("Deliverables","") or "").strip(),
        "Acceptance": (row.get("Acceptance Criteria","") or "").strip(),
        "Priority": (row.get("Priority","") or "").strip(),
        "Phase": (row.get("Phase","") or "").strip(),
        "Missing": (row.get("Missing Features","") or "").strip(),
        "Dependencies": (row.get("Dependencies","") or "").strip(),
        "Risks": (row.get("Risks/Mitigations","") or "").strip()
      }
except FileNotFoundError:
  print("UNCERTAIN: roadmap2.csv not found", file=sys.stderr); sys.exit(2)
if missing:
  print("UNCERTAIN: Missing tasks in roadmap2.csv → "+", ".join(missing), file=sys.stderr); sys.exit(3)
for k,v in found.items():
  print(f"WORKSTREAM_TASK_FOUND:{k}")
  print(f"{k}_META:"+json.dumps(v, ensure_ascii=False))
PY
      ]]>
    </command>
  </prechecks>

  <design>
    <mappingRules>
      <![CDATA[
Turn each task’s “Deliverables” text into concrete artifacts using these keyword→path rules (use exact filenames if the CSV specifies them; otherwise apply heuristics):

Core rendering & kernels:
- "WGSL", "compute", "shader", "kernel", "AOV" → src/shaders/<feature>.wgsl (add header docs: bind groups/bindings, formats, workgroup size).
- "BVH", "accel", "traversal" → src/accel/*.rs; src/path_tracing/accel.rs (+ WGSL hooks).
- "intersection", "ray-triangle/sphere/aabb" → src/path_tracing/intersect.rs; src/shaders/pt_intersect_*.wgsl.
- "materials", "BSDF", "PBR", "GGX", "clearcoat", "sheen" → src/pbr/*.rs; shaders/pbr_*.wgsl; python/forge3d/pbr.py.
- "sampling", "NEE", "MIS", "alias", "reservoir", "light tree" → src/lighting/*.rs; shaders/lighting_*.wgsl; python/forge3d/lighting.py.
- "denoise", "SVGF", "temporal", "TAA", "spatial" → src/denoise/*; shaders/svgf_*.wgsl; python/forge3d/path_tracing.py (flags).
- "wavefront", "queues", "compaction" → src/path_tracing/wavefront/**/*.rs; shaders/pt_*.wgsl.

Scene, IO & content:
- "camera", "DOF", "thin lens", "motion vectors" → src/camera/*.rs; shaders/camera_*.wgsl; python/forge3d/camera.py.
- "textures", "image", "mipmap", "sampler", "image io" → src/textures/*.rs; shaders/texture_*.wgsl; python/forge3d/textures.py.
- "mesh", "OBJ", "PLY", "glTF", "USD", "tangents" → src/mesh/*.rs; python/forge3d/mesh_io.py.
- "terrain", "heightmap", "tile", "geospatial", "map" → src/terrain/*.rs; python/forge3d/terrain.py; shaders/terrain_*.wgsl.
- "graphs", "layouts", "instancing", "colorscale" → src/scene/graph.rs; python/forge3d/graph.py; shaders/instancing_*.wgsl.

Pipelines, docs & UX:
- "tonemap", "ACES", "Reinhard", "exposure" → src/post/tonemap.rs; src/shaders/tonemap.wgsl; python bridge.
- "examples" → examples/<feature>_*.py (writes to out/; ensure .gitignore ignores out/).
- "docs" → README.md + docs/api/<feature>.md (if Sphinx present).
- "Python API" → python/forge3d/<feature>.py (public class/functions + type hints).

Tests:
- "tests", "validation", "golden", "bench" → tests/<feature>_*.rs or tests/test_<feature>*.py (GPU tests @skip if no adapter).

If any Deliverable bullet is ambiguous or lacks keywords, mark UNCERTAIN for that bullet with the minimal clarification needed and do not edit.
      ]]>
    </mappingRules>
  </design>

  <acceptanceCriteria>
    <ac id="AC-0">Rows for A19–A25 are present; each meta printed as <code>A19_META</code>…<code>A25_META</code> JSON.</ac>
    <ac id="AC-1">For every task (A19…A25), each concrete deliverable item exists as code/docs/tests artifacts with appropriate header/inline docs (bind groups for WGSL, public APIs for Python/Rust, type hints for Python).</ac>
    <ac id="AC-2">Public Python API exposes the functions/classes required by each task’s Acceptance Criteria; deterministic behavior documented for frames=1 with fixed seed where applicable.</ac>
    <ac id="AC-3">Unit/integration tests exist for all implemented deliverables; GPU-dependent tests are skipped when no compatible adapter is available; include at least one failure/validation path per task.</ac>
    <ac id="AC-4">Docs updated: README + docs/api/&lt;feature&gt;.md (if Sphinx present) clearly describing usage, parameters, conventions, and limitations; examples added if referenced.</ac>
    <ac id="AC-5">Validation run passes: <code>cargo fmt</code>, <code>cargo clippy -D warnings</code>, <code>cargo test</code>, <code>pytest</code>, <code>sphinx-build</code> (if docs), <code>maturin build</code>; CI ensured if missing.</ac>
  </acceptanceCriteria>

  <changes>
    <createOrModify>
      <!-- Final paths depend on each task’s deliverables; these directories are typical targets -->
      <file path="src/shaders/" kind="modify-or-new"/>
      <file path="src/path_tracing/" kind="modify-or-new"/>
      <file path="src/accel/" kind="modify-or-new-optional"/>
      <file path="src/lighting/" kind="modify-or-new-optional"/>
      <file path="src/pbr/" kind="modify-or-new-optional"/>
      <file path="src/camera/" kind="modify-or-new-optional"/>
      <file path="src/textures/" kind="modify-or-new-optional"/>
      <file path="src/mesh/" kind="modify-or-new-optional"/>
      <file path="src/scene/" kind="modify-or-new-optional"/>
      <file path="src/terrain/" kind="modify-or-new-optional"/>
      <file path="src/denoise/" kind="modify-or-new-optional"/>
      <file path="python/forge3d/" kind="modify-or-new"/>
      <file path="tests/" kind="modify-or-new"/>
      <file path="examples/" kind="modify-or-new-optional"/>
      <file path="README.md" kind="modify-append"/>
      <file path="docs/api/" kind="modify-or-new-optional"/>
      <file path=".gitignore" kind="modify-append"/>
    </createOrModify>
  </changes>

  <tests>
    <templates>
      <![CDATA[
- GPU tests (pytest): skip if no adapter; assert shapes/dtypes; determinism for frames=1 with fixed seed; numeric assertions aligned with each task’s AC (variance reduction, pdf normalization, bounds checks, etc.).
- Rust unit tests: struct packing/layout, math helpers, error handling (no panics across FFI boundaries).
- Docs build test: sphinx-build succeeds (or SKIPPED if docs absent).
- Example smoke tests (optional): scripts run headless and write to out/ (gitignored).
      ]]>
    </templates>
  </tests>

  <!-- EXACTLY INCLUDE THESE STEPS -->
  <plan>
    5) Implementation (Write mode only if &lt;WRITE_CHANGES&gt;true&lt;/WRITE_CHANGES&gt;)
       - Create branch: <code>git checkout -b ws-&lt;ID-or-slug&gt;-implementation</code>
       - For each task in deterministic order (by Priority then Task ID):
         * Apply minimal changes.
         * Add/update tests when <USE_TESTS>true</USE_TESTS>.
         * Update docs (Sphinx/README) and example scripts if referenced by AC.
         * Update CI if <ENSURE_CI>true</ENSURE_CI> and AC requires.
         * Keep one commit per task: <code>git commit -am "WS&lt;ID&gt; &lt;TaskID&gt;: &lt;short summary&gt;"</code>
       - Maintain safety: never delete custom user code; only remove generated artifacts (.pyd/.so, build/ etc.) when explicitly required by AC; otherwise add .gitignore entries.

    6) Validation Run
       - Commands (skip gracefully if tool missing; record SKIPPED):
         * <code>cargo fmt -- --check</code>
         * <code>cargo clippy --all-targets --all-features -D warnings</code>
         * <code>cargo test -q</code>
         * <code>pytest -q</code> (when <USE_TESTS>true</USE_TESTS>)
         * <code>sphinx-build -b html docs _build/html</code>
         * <code>maturin build --release</code>
         * <code>cmake -S . -B build && cmake --build build</code> (if CMake wrapper is part of AC)
       - Re-run the audit matrix; all tasks should now be <b>Present & Wired</b>.
       - If any still failing → fix or mark explicitly BLOCKED with reason.

    7) PR Preparation
       - Generate <b>PR_BODY.md</b> summarizing: scope, tasks addressed, evidence, risks/mitigations, and validation output.
       - Print final change summary: <code>git status -s</code>, <code>git log --oneline -n 50</code>.
  </plan>

  <execution>
    <steps>
      <step>Create feature branch: <code>git checkout -b ws-A19-A25-implementation</code></step>
      <step>Parse A19_META…A25_META into bullet items (split by newlines/semicolons). Save combined mapping to <code>reports/a19_a25_plan.json</code> (task → deliverable → files/symbols) using the mapping rules.</step>
      <step>Process tasks in deterministic order (Priority, then Task ID). For each task:
        <ul>
          <li>Implement minimal, correct code in WGSL/Rust/Python to meet that task’s Deliverables and AC.</li>
          <li>Add/modify tests (Rust/Python) covering success paths and at least one failure/validation path tied to the AC.</li>
          <li>Update README and docs/api/&lt;feature&gt;.md (if Sphinx present) with usage, parameters, conventions, and limitations.</li>
          <li>If examples requested: add example(s) in <code>examples/</code>, writing outputs to <code>out/</code> (ensure .gitignore ignores it).</li>
          <li>Commit: <code>git commit -am "WSA &lt;TaskID&gt;: &lt;short summary of change&gt;"</code></li>
        </ul>
      </step>
      <step>Append <code>.gitignore</code> entries for out/, diag_out/, and build artifacts if needed.</step>
      <step>Run the Validation Run commands; fix non-flaky failures; mark SKIPPED where tools are absent and record the exact command.</step>
      <step>Create <code>PR_BODY.md</code> summarizing A19–A25 implementations with references to files/lines and validation results; print <code>git status -s</code> and <code>git log --oneline -n 50</code>.</step>
    </steps>
  </execution>

  <completion>
    <print>
      - reports/a19_a25_plan.json
      - All created/modified WGSL/Rust/Python sources per mapping for A19–A25
      - tests/* covering each implemented feature
      - examples/* (if requested by any task)
      - README.md (updated)
      - docs/api/* (if Sphinx present)
      - PR_BODY.md
    </print>
    <fallback>
      If any of A19–A25 are not found or their Deliverables/Acceptance text is empty/ambiguous, respond <b>UNCERTAIN</b> listing the exact missing fields and STOP without changes.
    </fallback>
  </completion>
</task>
