````xml
<task name="Introduce Colormaps System to forge3d" owner="@milosmakesmaps" priority="P0">
  <goal>
    Add a robust, extensible, CVD-safe colormap system to forge3d with:
    (1) a tiny vendored core set (no heavy deps), (2) optional adapters to external libraries via extras,
    (3) LUT-first GPU representation (linear sRGB) using a 2D 1×N texture in WGSL, (4) CPT/JSON import,
    (5) tests (perceptual/CVD checks), (6) docs and examples.
  </goal>

  <acceptance_criteria>
    <item>Users can call forge3d.colormaps.get("forge3d:viridis") and receive a Colormap with (N,4) float32 linear-sRGB LUT.</item>
    <item>Optional adapters resolve when corresponding extra is installed: e.g., forge3d[colormaps] enabling cmcrameri/cmocean/colorcet/palettable/pycpt.</item>
    <item>Imhof CPT loads via pycpt and renders through the same pipeline.</item>
    <item>Shaders sample a 2D LUT (width=N, height=1) without per-fragment branching for under/over/bad.</item>
    <item>Unit tests pass: monotonic L* for sequential ramps, basic CVD separability checks, LUT hash determinism.</item>
    <item>Docs include “Colormaps” page with code samples; gallery example renders a DEM with batlow-like default and with an Imhof CPT.</item>
  </acceptance_criteria>

  <repo>
    <path>python/forge3d/</path>
    <path>src/</path>
    <path>docs/</path>
    <path>examples/</path>
    <path>pyproject.toml</path>
  </repo>

  <plan>
    <step>Add new Python package: python/forge3d/colormaps/ (core, registry, adapters, IO)</step>
    <step>Expose public API in python/forge3d/colormaps/__init__.py</step>
    <step>Add optional extras and entry points in pyproject.toml</step>
    <step>Add WGSL colormap sampler module and Rust/WGPU glue to upload LUT as 2D (N×1) texture + sampler</step>
    <step>Wire colormap selection into existing raster/mesh material pipelines (Python bindings to set LUT and range)</step>
    <step>Implement CPT/JSON loaders</step>
    <step>Add tests (pytest) for color/CIELAB, CVD simulation, hashing, shader snapshot</step>
    <step>Write docs and two runnable examples</step>
  </plan>

  <edits>
    <!-- 1) Python core: dataclass, utilities, registry -->
    <create_file path="python/forge3d/colormaps/core.py">
      <![CDATA[
from __future__ import annotations
from dataclasses import dataclass
import numpy as np

# --- Color space helpers (sRGB <-> linear) ---
def _srgb_to_linear(c: np.ndarray) -> np.ndarray:
    a = 0.055
    return np.where(c <= 0.04045, c / 12.92, ((c + a) / (1 + a)) ** 2.4)

def _hex_to_rgba_linear(hex_s: str, alpha: float = 1.0) -> np.ndarray:
    hex_s = hex_s.lstrip("#")
    r = int(hex_s[0:2], 16) / 255.0
    g = int(hex_s[2:4], 16) / 255.0
    b = int(hex_s[4:6], 16) / 255.0
    rgb_lin = _srgb_to_linear(np.array([r, g, b], dtype=np.float32))
    return np.array([*rgb_lin, alpha], dtype=np.float32)

def _interp_stops(stops, n: int) -> np.ndarray:
    # stops: list[(pos0..1, "#RRGGBB" or (r,g,b[,a]))]
    xs = np.array([s[0] for s in stops], dtype=np.float32)
    cols = []
    for s in stops:
        c = s[1]
        if isinstance(c, str):
            cols.append(_hex_to_rgba_linear(c))
        else:
            c = np.array(c, dtype=np.float32)
            if c.size == 3:
                c = np.concatenate([c, [1.0]], axis=0)
            cols.append(_srgb_to_linear(c[:3]).tolist() + [float(c[3])])
    cols = np.array(cols, dtype=np.float32)  # (k,4)
    x = np.linspace(0.0, 1.0, n, dtype=np.float32)
    rgba = np.column_stack([np.interp(x, xs, cols[:, i]) for i in range(4)]).astype(np.float32)
    return np.clip(rgba, 0.0, 1.0)

@dataclass(frozen=True)
class Colormap:
    name: str
    rgba: np.ndarray           # shape (N,4), linear sRGB, float32
    under: tuple | None = None # linear sRGB
    over: tuple | None = None
    bad: tuple | None = (0.0, 0.0, 0.0, 0.0)

    def reversed(self) -> "Colormap":
        return Colormap(self.name + "_r", self.rgba[::-1].copy(), self.under, self.over, self.bad)

    def with_endcaps(self, under=None, over=None, bad=None) -> "Colormap":
        return Colormap(self.name, self.rgba, under if under is not None else self.under,
                        over if over is not None else self.over, bad if bad is not None else self.bad)

def from_stops(name: str, stops, n: int = 256) -> Colormap:
    return Colormap(name=name, rgba=_interp_stops(stops, n=n))
      ]]>
    </create_file>

    <create_file path="python/forge3d/colormaps/registry.py">
      <![CDATA[
from __future__ import annotations
from typing import Dict, Callable
from .core import Colormap
import numpy as np

_REGISTRY: Dict[str, Callable[[], Colormap]] = {}

def register(name: str, factory: Callable[[], Colormap]) -> None:
    key = name.lower()
    if key in _REGISTRY:
        raise ValueError(f"Colormap already registered: {name}")
    _REGISTRY[key] = factory

def get(name: str) -> Colormap:
    key = name.lower()
    if key in _REGISTRY:
        return _REGISTRY[key]()
    # try provider:name form
    if ":" in key:
        provider, _, cname = key.partition(":")
        from .providers import load_provider
        return load_provider(provider)(cname)
    raise KeyError(f"Unknown colormap: {name} (available={list(_REGISTRY.keys())})")

def available() -> list[str]:
    return sorted(_REGISTRY.keys())

def to_linear_rgba_u8(cm: Colormap) -> bytes:
    # Convert float32 0..1 to u8 for texture upload (premultiplied alpha not required)
    arr = (np.clip(cm.rgba, 0.0, 1.0) * 255.0 + 0.5).astype("uint8")
    return arr.tobytes()
      ]]>
    </create_file>

    <create_file path="python/forge3d/colormaps/core_palettes.py">
      <![CDATA[
from __future__ import annotations
import numpy as np
from .core import from_stops
from .registry import register

# Minimal, permissive, CVD-safe core (no heavy deps)
# viridis-like (license-safe approximation)
_VIRIDIS_STOPS = [
    (0.0,  "#440154"), (0.13, "#472C7A"), (0.25, "#3B518B"),
    (0.38, "#2C718E"), (0.5, "#21918C"), (0.63, "#2DB27D"),
    (0.75, "#73D055"), (0.88, "#DCE319"), (1.0,  "#FDE725"),
]
_MAGMA_STOPS = [
    (0.0, "#000004"), (0.2, "#3B0F70"), (0.4, "#8C2981"),
    (0.6, "#DE4968"), (0.8, "#FE9F6D"), (1.0, "#FCFDBF"),
]
# vik-like (diverging around mid)
_VIK_STOPS = [
    (0.0, "#00224E"), (0.25, "#2E6DB4"), (0.5, "#F5F5F5"),
    (0.75, "#C14A3B"), (1.0, "#5A0000"),
]
# Okabe–Ito (categorical seed, exposed as utility)
OKABE_ITO = ["#000000","#E69F00","#56B4E9","#009E73","#F0E442","#0072B2","#D55E00","#CC79A7"]

def _register_core():
    register("forge3d:viridis", lambda: from_stops("forge3d:viridis", _VIRIDIS_STOPS, 256))
    register("forge3d:magma",   lambda: from_stops("forge3d:magma",   _MAGMA_STOPS,   256))
    register("forge3d:vik",     lambda: from_stops("forge3d:vik",     _VIK_STOPS,     256))
_register_core()
      ]]>
    </create_file>

    <create_file path="python/forge3d/colormaps/providers.py">
      <![CDATA[
from __future__ import annotations
from typing import Callable
import importlib
import numpy as np
from .core import Colormap

def _mpl_to_colormap(mpl_cmap, name: str, n: int = 256) -> Colormap:
    xs = np.linspace(0, 1, n, dtype=np.float32)
    rgba_srgb = np.array(mpl_cmap(xs), dtype=np.float32)  # (n,4) in sRGB
    # convert to linear sRGB:
    a = 0.055
    rgb = rgba_srgb[:, :3]
    rgb_lin = np.where(rgb <= 0.04045, rgb / 12.92, ((rgb + a) / (1 + a)) ** 2.4)
    rgba_lin = np.concatenate([rgb_lin, rgba_srgb[:, 3:4]], axis=1).astype(np.float32)
    return Colormap(name, rgba_lin)

def load_provider(provider: str) -> Callable[[str], Colormap]:
    p = provider.lower()
    if p == "cmcrameri":
        def f(name: str) -> Colormap:
            cmc = importlib.import_module("cmcrameri.cm")
            mpl_cmap = getattr(cmc, name)
            return _mpl_to_colormap(mpl_cmap, f"cmcrameri:{name}")
        return f
    if p == "cmocean":
        def f(name: str) -> Colormap:
            cmo = importlib.import_module("cmocean.cm")
            mpl_cmap = getattr(cmo, name)
            return _mpl_to_colormap(mpl_cmap, f"cmocean:{name}")
        return f
    if p == "colorcet":
        def f(name: str) -> Colormap:
            cc = importlib.import_module("colorcet")
            mpl_cmap = cc.cm[name]
            return _mpl_to_colormap(mpl_cmap, f"colorcet:{name}")
        return f
    if p == "palettable":
        def f(name: str) -> Colormap:
            # name like "colorbrewer.sequential.YlGn_9"
            mod = importlib.import_module("palettable." + ".".join(name.split(".")[:-1]))
            obj = getattr(mod, name.split(".")[-1])
            return _mpl_to_colormap(obj.mpl_colormap, f"palettable:{name}")
        return f
    if p == "pycpt":
        def f(path_or_name: str) -> Colormap:
            # path or name resolved by pycpt loaders
            m = importlib.import_module("pycpt")
            cmap = m.load(path_or_name)
            # pycpt returns a Matplotlib cmap
            return _mpl_to_colormap(cmap, f"pycpt:{path_or_name}")
        return f
    raise KeyError(f"Unknown provider: {provider}")
      ]]>
    </create_file>

    <create_file path="python/forge3d/colormaps/io.py">
      <![CDATA[
from __future__ import annotations
import json
from .core import Colormap, from_stops

def load_json(path: str, n: int = 256) -> Colormap:
    with open(path, "r", encoding="utf-8") as f:
        spec = json.load(f)
    name = spec.get("name", path)
    stops = spec["stops"]  # list of [pos, color]
    return from_stops(name, stops, n=n)

def load_cpt(path: str, n: int = 256) -> Colormap:
    try:
        from .providers import load_provider
        return load_provider("pycpt")(path)
    except Exception as e:
        raise RuntimeError("pycpt required for CPT files. Install forge3d[colormaps].") from e
      ]]>
    </create_file>

    <create_file path="python/forge3d/colormaps/__init__.py">
      <![CDATA[
from .core import Colormap
from .registry import register, get, available, to_linear_rgba_u8
from .core_palettes import OKABE_ITO  # triggers core registration on import
from .io import load_json, load_cpt
__all__ = ["Colormap", "register", "get", "available", "to_linear_rgba_u8", "OKABE_ITO", "load_json", "load_cpt"]
      ]]>
    </create_file>

    <!-- 2) pyproject: extras + entry points -->
    <update_file path="pyproject.toml" pattern="\[project\]">
      <![CDATA[
[project.optional-dependencies]
colormaps = [
  "cmcrameri>=1.7",
  "cmocean>=3.0",
  "colorcet>=3.0.0",
  "palettable>=3.3.3",
  "pycpt>=0.5.0",
]

[project.entry-points."forge3d.colormaps"]
# third parties can register here; example kept for docs
# mypkg = "mypkg.colormaps:entrypoint"
      ]]>
    </update_file>

    <!-- 3) WGSL shader + Rust/WGPU glue -->
    <create_file path="src/shaders/colormap.wgsl">
      <![CDATA[
// 2D LUT sampler (width=N, height=1)
@group(2) @binding(0) var colormap_tex : texture_2d<f32>;
@group(2) @binding(1) var colormap_smp : sampler;

struct ColormapPush {
  vmin: f32,
  vmax: f32,
  clamp_under: f32,  // 1.0 to clamp to under color (texel 0)
  clamp_over: f32,   // 1.0 to clamp to over color (texel N-1)
  tex_w: f32,        // LUT width as float (N)
};
@group(2) @binding(2) var<uniform> cmap : ColormapPush;

fn colormap_sample(value: f32) -> vec4f {
  // Normalize to 0..1
  var t = saturate((value - cmap.vmin) / max(cmap.vmax - cmap.vmin, 1e-8));
  // Convert to tex coords in 0..(N-1)
  let coord = vec2f(t * (cmap.tex_w - 1.0), 0.0);
  // sample at center of texels
  let uv = (coord + vec2f(0.5, 0.5)) / vec2f(cmap.tex_w, 1.0);
  return textureSample(colormap_tex, colormap_smp, uv);
}
      ]]>
    </create_file>

    <update_file path="src/renderer/colormap.rs" create_if_missing="true">
      <![CDATA[
use wgpu::*;
pub struct ColormapGpu {
    pub texture: Texture,
    pub view: TextureView,
    pub sampler: Sampler,
    pub width: u32,
}
impl ColormapGpu {
    pub fn from_rgba_u8(device: &Device, queue: &Queue, data: &[u8], width: u32) -> Self {
        let size = Extent3d { width, height: 1, depth_or_array_layers: 1 };
        let texture = device.create_texture(&TextureDescriptor {
            label: Some("forge3d_colormap"),
            size, mip_level_count: 1, sample_count: 1,
            dimension: TextureDimension::D2,
            format: TextureFormat::Rgba8Unorm, usage: TextureUsages::TEXTURE_BINDING | TextureUsages::COPY_DST,
            view_formats: &[],
        });
        queue.write_texture(
            ImageCopyTexture { texture: &texture, mip_level: 0, origin: Origin3d::ZERO, aspect: TextureAspect::All },
            data, ImageDataLayout { offset: 0, bytes_per_row: Some(width * 4), rows_per_image: Some(1) },
            size,
        );
        let view = texture.create_view(&TextureViewDescriptor::default());
        let sampler = device.create_sampler(&SamplerDescriptor {
            label: Some("forge3d_colormap_sampler"),
            address_mode_u: AddressMode::ClampToEdge,
            address_mode_v: AddressMode::ClampToEdge,
            mag_filter: FilterMode::Linear, min_filter: FilterMode::Linear, mipmap_filter: FilterMode::Nearest,
            ..Default::default()
        });
        Self { texture, view, sampler, width }
    }
}
      ]]>
    </update_file>

    <update_file path="python/forge3d/render/colormap_binding.py" create_if_missing="true">
      <![CDATA[
from __future__ import annotations
import numpy as np
from ..colormaps import get, to_linear_rgba_u8
from .._native import gpu  # cffi/pybind handle into Rust layer

class GpuColormapHandle:
    def __init__(self, name: str):
        cm = get(name)
        self.name = name
        self.width = cm.rgba.shape[0]
        rgba_u8 = to_linear_rgba_u8(cm)
        self._handle = gpu.upload_colormap_texture(rgba_u8, self.width)  # -> native handle

    def bind_to(self, pass_obj):
        # Attach to bind group set 2 (tex,sampler,uniform) per shader layout
        pass_obj.bind_colormap(self._handle, width=self.width)
      ]]>
    </update_file>

    <!-- 4) Public API hook (optional convenience) -->
    <update_file path="python/forge3d/__init__.py" pattern="^" multiple="false">
      <![CDATA[
# Colormaps public surface
from .colormaps import get as get_colormap, available as available_colormaps, load_cpt as load_cpt_colormap, load_json as load_json_colormap
      ]]>
    </update_file>

    <!-- 5) Tests -->
    <create_file path="python/tests/test_colormaps_core.py">
      <![CDATA[
import numpy as np
from forge3d.colormaps import get, available
from colorspacious import cspace_convert

def test_core_available_min():
    keys = available()
    assert any(k.endswith("forge3d:viridis") for k in keys) or ("forge3d:viridis" in keys)

def test_monotonic_lightness():
    cm = get("forge3d:viridis")
    rgb = cm.rgba[:, :3]
    # convert linear sRGB to sRGB before LAB conversion (colorspacious expects sRGB)
    def lin_to_srgb(x): 
        a=0.055; return np.where(x<=0.0031308, x*12.92, (1+a)*np.power(x,1/2.4)-a)
    srgb = lin_to_srgb(rgb)
    lab = cspace_convert(srgb, "sRGB1", "CIELab")
    L = lab[:,0]
    # allow small numerical noise
    diffs = np.diff(L)
    assert (diffs >= -1e-2).all()

def test_hash_determinism():
    cm1 = get("forge3d:viridis")
    cm2 = get("forge3d:viridis")
    assert np.allclose(cm1.rgba, cm2.rgba)
      ]]>
    </create_file>

    <create_file path="python/tests/test_colormaps_cvd.py">
      <![CDATA[
import numpy as np
from forge3d.colormaps import get
from colorspacious import cspace_convert

def simulate_cvd(rgb, deficiency="deuteranomaly"):
    return cspace_convert(rgb, "sRGB1", ("sRGB1+CVD", deficiency, 100))

def test_vik_diverging_zero_contrast():
    cm = get("forge3d:vik")
    rgb_lin = cm.rgba[:, :3]
    def lin_to_srgb(x): 
        a=0.055; return np.where(x<=0.0031308, x*12.92, (1+a)*np.power(x,1/2.4)-a)
    srgb = lin_to_srgb(rgb_lin)
    cvd = simulate_cvd(srgb)
    # ensure endpoints remain distinguishable
    assert np.linalg.norm(cvd[0]-cvd[-1]) > 0.2
      ]]>
    </create_file>

    <!-- 6) Docs -->
    <create_file path="docs/colormaps.md">
      <![CDATA[
# Colormaps in forge3d

## Quick start
```python
from forge3d.colormaps import get, available
cm = get("forge3d:viridis")
````

## Optional providers

Install extras: `pip install "forge3d[colormaps]"`

Use:

```python
get("cmcrameri:batlow")
get("cmocean:deep")
get("colorcet:glasbey")
from forge3d.colormaps import load_cpt
cm = load_cpt("imhof_1.cpt")
```

## GPU details

* LUT baked to linear sRGB, uploaded as 2D texture (N×1), sampled in WGSL.
* Set vmin/vmax and colormap during render pass.
  ]]>
  </create_file>

    <!-- 7) Examples -->

  <create_file path="examples/colormap_dem.py">
  <![CDATA[
  import numpy as np
  from forge3d.colormaps import get

# Pseudocode for your existing render pipeline:

# dem = load_dem(...)

cm = get("forge3d:viridis")  # or "cmcrameri:batlow" if extras installed

# scene = forge3d.Scene()

# scene.set_colormap(cm, vmin=dem.min(), vmax=dem.max())

# scene.render_heightmap(dem)

  ]]>
</create_file>

  </edits>

  <notes>
    <licensing>
      Core ramps mimic viridis/magma/vik via custom stops; keep provenance in docs.
      Do not vendor third-party palettes with restrictive licenses; rely on optional extras.
    </licensing>
    <performance>
      Default LUT size 256; allow 1024 via env/param for high-frequency ramps.
      Cache converted LUTs by name+size+version in ~/.cache/forge3d if desired (future task).
    </performance>
    <integration>
      Bind group index (2) is illustrative—align with your pipeline layouts if different.
      If your engine already has a material uniform block, add vmin/vmax + tex_w there.
    </integration>
  </notes>

<followup_tasks> <task>Expose legend/NaN/under/over color handling via material params (encode endcaps in LUT or separate uniforms).</task> <task>Add hillshade multiply/add in shader with tunable intensity, ensuring linear-space math.</task> <task>Add gallery notebook comparing cmcrameri vs CPT Imhof on the same DEM.</task>
</followup_tasks> </task>
