**PROMPT FOR CHATGPT CODEX HIGH REASONING**

 **ROLE**
 You are a senior real-time graphics engineer working on the `forge3d` renderer (Rust + WebGPU/WGSL, Vulkan-friendly). Your job is to **implement the entire P5.2 SSGI feature in one go**, from shaders to Rust pass and test outputs, without breaking existing rendering.

 ---

 **GOAL – P5.2 SSGI**
 Implement **Screen-Space Global Illumination (SSGI)** with:

 * Half-resolution view-space tracing along the **bent normal**.
 * Diffuse radiance from **previous-frame color buffer** with **diffuse IBL fallback** on miss.
 * **Temporal accumulation** with clamping.
 * **Edge-aware upsample** to full resolution.
   Wire it into a new Rust pass and expose hot parameters via CLI / viewer commands.
   Produce the requested PNG outputs and update `p5_meta.json` with SSGI stats and timings.

 ---

 **SCOPE & FILES (MUST EXIST AFTER YOUR CHANGES)**
 **WGSL**

 1. `src/shaders/ssgi/trace.wgsl`

    * Half-resolution ray-march in view space.
    * March along the **bent normal** using sphere-traced steps.
    * Step count controlled by `:ssgi-steps`.
    * Trace distance / radius controlled by `:ssgi-radius`.
    * Uses **hierarchical Z-buffer (HZB)** for occlusion tests (coarse-to-fine depth test).
    * Outputs: hit position, hit normal, hit mask, and miss flag for each half-res pixel.
 2. `src/shaders/ssgi/shade.wgsl`

    * Samples **previous-frame color buffer** (ping-pong target) at the traced hit position.
    * If trace misses or depth test fails, returns **diffuse IBL fallback**.
    * Outputs a **half-res diffuse GI radiance** buffer.
 3. `src/shaders/ssgi/resolve_temporal.wgsl`

    * Inputs: current half-res SSGI radiance, previous SSGI history, motion vectors (if available), depth/normal.
    * Reprojects history using motion vectors (fallback: no reprojection if unavailable).
    * Blends: `history = lerp(history, current, temporal_alpha)` where `temporal_alpha` comes from a hot param.
    * Applies **neighborhood clamp** (min/max in a small kernel) to avoid ghosting and fireflies.
    * Writes the **half-res temporally accumulated SSGI** buffer.
 4. `src/shaders/filters/edge_aware_upsample.wgsl`

    * Inputs: half-res SSGI (temporally accumulated), full-res depth, full-res normal.
    * Edge-aware upsample from half to full resolution using bilateral weights:

      * spatial + depth + normal terms, with **configurable sigmas** (hot params).
    * Outputs full-res SSGI radiance suitable for compositing into the GI path.

 **Rust**
 5. `src/passes/ssgi.rs`

 * Creates and manages:

   * Half-res textures for trace hit data, radiance, and temporal history.
   * Ping-pong previous-frame color buffer (for shading) and SSGI history buffer.
 * Sets up pipelines and bind groups for:

   * `ssgi/trace.wgsl`
   * `ssgi/shade.wgsl`
   * `ssgi/resolve_temporal.wgsl`
   * `filters/edge_aware_upsample.wgsl`
 * Dispatch order each frame (pseudo):

   1. Build / update HZB depth pyramid.
   2. Half-res SSGI trace pass.
   3. Shade pass (sample prev color + IBL fallback).
   4. Temporal resolve pass (if temporal enabled).
   5. Edge-aware upsample to full-res.
   6. Composite full-res SSGI into the GI buffer (diffuse only).
 * Manages history lifetime: clears or re-initializes on resize, camera cut, or major GI changes.

 ---

 **PARAMS & CONTROLS (MUST BE WIRED END-TO-END)**
 Extend the renderer’s params (e.g., `GiParams` or `SsgiParams`) and viewer/CLI so the following **hot parameters** work at runtime:

 * `:ssgi-steps <int`

   * Number of sphere-trace steps in `trace.wgsl`.
 * `:ssgi-radius <float`

   * Maximum trace distance in view space.
 * `:ssgi-half on|off`

   * Enables/disables half-res tracing (off can force full-res for debugging, but default is on).
 * `:ssgi-temporal-alpha <float`

   * Temporal blend alpha (0–1) used in `resolve_temporal.wgsl`.
 * `:ssgi-temporal on|off`

   * Toggles temporal accumulation and history usage.
 * `:ssgi-upsample-sigma-depth <float`
 * `:ssgi-upsample-sigma-normal <float`

   * Control depth/normal weight falloff in `edge_aware_upsample.wgsl`.

 These should immediately update internal params and affect subsequent frames without restart.

 ---

 **DELIVERABLES (GENERATE THESE FROM A TEST HARNESS)**
 Implement or update a simple P5 Cornell-box harness so you can render the following PNGs:

 1. `reports/p5/p5_ssgi_cornell.png`

    * Cornell box with **a red wall and a green wall** (reference albedos set in the scene).
    * Must clearly show **visible red/green bounce** onto adjacent neutral walls with SSGI ON.
    * Show a split or side-by-side comparison: SSGI OFF vs SSGI ON.
 2. `reports/p5/p5_ssgi_temporal_compare.png`

    * Static camera.
    * Left: **single-frame SSGI** (no temporal accumulation, alpha=1 or temporal disabled).
    * Right: **16-frame accumulated SSGI** with the temporal pass enabled and a reasonable `temporal_alpha`.
    * Same camera & scene; only accumulation differs.
 3. Update `reports/p5/p5_meta.json` (or P5 section) to add an **`ssgi` block** with at least:

    * `miss_ratio` – fraction of rays that miss geometry (and fall back to IBL).
    * `avg_steps` – average trace steps actually taken (after early exits).
    * `accumulation_alpha` – the temporal alpha used in `resolve_temporal.wgsl`.
    * `perf_ms` – timings in milliseconds:

      * `trace_ms`, `shade_ms`, `temporal_ms`, `upsample_ms`, and `total_ssgi_ms`.

 Leave existing SSAO/GTAO metadata intact.

 ---

 **ACCEPTANCE CRITERIA (MUST ALL PASS)**
 Implement metrics/tests so the following numeric conditions hold for the Cornell test:

 1. **Wall bounce (diffuse GI contribution)**

    * With SSGI OFF, measure mean luminance in:

      * ROI A: neutral wall adjacent to the **red wall**.
      * ROI B: neutral wall adjacent to the **green wall**.
    * With SSGI ON (same ROIs, same camera):

      * The neutral wall adjacent to the red wall must have **+5% to +12% luminance increase** vs SSGI OFF.
      * Same order of magnitude for the green-adjacent wall.
      * The bounced color must stay **below the ACES tone-mapping clamp** (no saturation clipping).
 2. **Temporal stability**

    * For a static camera, render a sequence with temporal SSGI enabled using your chosen `temporal_alpha`.
    * Compute **frame-to-frame SSIM** between frame 8 and frame 9 in SSGI-affected regions.
    * Requirement: `SSIM ≥ 0.95` after 8 frames (temporal accumulation has largely converged).
 3. **Fallback correctness (IBL)**

    * When the user runs `:ssgi-steps 0`, the trace pass must effectively skip ray marching and rely purely on **diffuse IBL**.
    * In this mode, the SSGI result must match your **diffuse IBL solution** within:

      * Color difference `ΔE ≤ 1.0` (CIEDE2000 or similar) across tested ROIs.
    * Implement a check that compares SSGI output vs diffuse IBL reference and records the max ΔE in `p5_meta.json`.

 If any condition fails, adjust parameters (radius, steps, temporal alpha, upsample sigmas) and/or shader logic but do **not** break correctness in other passes.

 ---

 **OUTPUT (WHAT YOU RETURN IN YOUR ANSWER)**
 In a single response:

 1. Provide complete WGSL code for:

    * `src/shaders/ssgi/trace.wgsl`
    * `src/shaders/ssgi/shade.wgsl`
    * `src/shaders/ssgi/resolve_temporal.wgsl`
    * `src/shaders/filters/edge_aware_upsample.wgsl`
 2. Provide complete Rust code (or clearly scoped diffs) for:

    * `src/passes/ssgi.rs`
    * Any param / struct / viewer command wiring needed to support the SSGI hot params.
 3. Describe briefly how to run the P5 SSGI harness to regenerate:

    * `p5_ssgi_cornell.png`
    * `p5_ssgi_temporal_compare.png`
    * the updated `p5_meta.json` with SSGI metrics and timings.
 4. Assume the rest of the engine already compiles and runs; keep all changes **backwards-compatible** with existing P5 passes.

 Your response must be self-contained so that an engineer can paste in the code, run the P5 harness, and satisfy all P5.2 requirements without further clarification.
