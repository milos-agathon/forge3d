You are a senior graphics/QA engineer on the forge3d project.

GOAL
Finish P5 milestone M2 for the SSR glossy test by fixing the **thickness ablation QA metric** so that it reflects the real SSR behavior. The current implementation “cheats” by nudging metrics when they are equal. You must replace this with a robust, image-driven measurement, while preserving the already-working stripe QA.

CONTEXT (CURRENT STATE)
- Repo: forge3d (Rust + wgpu/wgsl viewer).
- P5 examples of interest:
  - `examples/p5_ssr_glossy.rs`
  - `examples/p5_ssr_thickness_ablation.rs`
- QA report:
  - `reports/p5/p5_meta.json` currently reports:
    - `"status": "SSR_QA_OK"`, `"ssr_status": "SSR_QA_OK"`
    - `stripe_analysis.reference[...]` and `stripe_analysis.ssr[...]` are non-zero and monotonic.
    - `thickness_ablation` is:
      - `"undershoot_before": 0.001...`
      - `"undershoot_after": 0.0`
- Recent changes:
  - `src/p5/ssr_analysis.rs`: Stripe analysis was rewritten to auto-detect the stripe ROI from the images and compute per-band Michelson contrasts. This is OK and should be preserved unless you find a **concrete bug**.
  - `src/viewer/mod.rs`: The thickness ablation logic includes a guard that, when `undershoot_before == undershoot_after`, artificially nudges `undershoot_before` upward so the delta is positive. This is NOT acceptable for M2 and must be removed.

HARD CONSTRAINTS
1. **Do NOT**:
   - Do not hack the metrics by clamping or nudging values just to satisfy the test.
   - Do not modify the SSR shader (`shaders/ssr.wgsl`), scene JSON, stripe generation, or material parameters just to game the QA numbers.
   - Do not re-break the already-passing stripe QA (the `stripe_analysis` section in `p5_meta.json` must remain structurally similar and still pass).

2. **You MAY**:
   - Refactor or extend the **thickness ablation analysis code** to compute a better metric.
   - Adjust how the thickness ablation example renders its two passes (e.g., camera, ROI, sampling locations) if that’s necessary to expose a real, measurable undershoot difference, as long as the images remain visually sensible and consistent with p5 specs.
   - Clean up JSON output fields if needed (e.g., deprecate `stripe_contrast` in favor of `stripe_analysis`, provided all consuming code is updated accordingly).

EXPLICIT TASKS

Task 1 – Locate the true source of thickness_ablation metrics
1. Find where `thickness_ablation.undershoot_before` and `thickness_ablation.undershoot_after` are computed and written into `p5_meta.json`.
   - Search in `src/p5`, `src/viewer/mod.rs`, or any helper modules.
2. Identify the exact code path used when running:
   - `cargo run --release --example p5_ssr_thickness_ablation`
   - and how that flows into the report writer.

Deliverable for Task 1:
- Clear inline comments (in the code) explaining where the ablation values come from and which image(s) / render passes they are based on.

Task 2 – Remove the cheating guard
1. In `src/viewer/mod.rs` (or wherever it lives), **remove** any logic that:
   - Detects `undershoot_before == undershoot_after` (or nearly equal) and then forces `undershoot_before` to be larger by adding an epsilon.
   - Any other code that adjusts these metrics after they are measured purely to satisfy a sign/delta condition.
2. After removal, `undershoot_before` and `undershoot_after` must be **direct outputs of an image-based measurement pipeline**, not post-processed.

Deliverable for Task 2:
- No metric writes in the code should contain hard-coded values, epsilons, or “if they’re equal, bump one up” logic.

Task 3 – Implement a robust, physical thickness ablation metric
Design and implement a **data-driven** measure of how much SSR “undershoots” when thickness is too small, such that:
- You render at least two configurations using the *same* camera and scene:
  - A baseline thickness (e.g., the intended production value).
  - A thinner thickness (e.g., smaller by a known factor) that should produce more leaks / undershoot.
- You then compute, from the resulting images, **per-pixel or per-region statistics** that quantify undershoot (missed or overly short reflections).

Constraints for the metric:
1. It must be computed from real image data:
   - For example, you can define a stripe-aligned ROI (similar to `ssr_analysis`) and:
     - Compare reference vs SSR brightness in that ROI for “before” and “after” thickness values.
     - Compute how much of the SSR reflection is darker than the reference by more than some threshold.
   - Exactly how you compute “undershoot” is your design, but it must be:
     - Deterministic.
     - Based on pixel values.
     - Commented clearly.

2. The expected outcomes:
   - `undershoot_before` (baseline thickness) should be **small but non-zero**.
   - `undershoot_after` (too-thin thickness) should be **larger** than `undershoot_before`, because more rays miss the actual geometry due to insufficient thickness.
   - The magnitude should be stable across runs (no noisy randomness).

3. Numerical constraints (you choose thresholds, but justify them in comments):
   - Use a luminance or luma measure (e.g., standard Rec.709 coefficients) or similar.
   - Use thresholds that avoid noise (e.g., ignore tiny <1e-4 differences).

Implementation guidance:
- Prefer to implement the analysis in a `src/p5/*` helper (e.g., `thickness_ablation.rs`) that:
  - Loads the rendered images.
  - Converts them to linear space if appropriate.
  - Computes undershoot_before/after as scalar metrics.
  - Writes them into the report struct consumed by `p5_meta.json`.
- Ensure that all file paths and image names used are clearly tied to the P5 ablation example (don’t rely on magic constants scattered across files).

Task 4 – Update reporting and tests
1. Ensure that after running:
   - `cargo run --release --example p5_ssr_glossy`
   - `cargo run --release --example p5_ssr_thickness_ablation`
   you regenerate `reports/p5/p5_meta.json` with:
   - `"status": "SSR_QA_OK"`
   - `"ssr_status": "SSR_QA_OK"`
   - `stripe_analysis.*` unchanged in structure and still passing (monotonic flags true, min contrast thresholds satisfied).
   - `thickness_ablation.undershoot_before` **strictly less than** `thickness_ablation.undershoot_after`, both >= 0, with values derived purely from the new metric.

2. If `stripe_contrast` is now obsolete:
   - Either populate it consistently from `stripe_analysis` or remove/replace its usage everywhere (no dead, confusing fields in `p5_meta.json`).

Task 5 – Final cleanup
1. Run `cargo fmt` and `cargo clippy` (if reasonable) to keep the codebase clean.
2. In a final comment at the top of the thickness ablation analysis function, summarize:
   - What the metric measures.
   - How it’s computed.
   - Why it differentiates between baseline and too-thin SSR thickness.

OUTPUT BACK TO ME
When you’re done, summarize:
- The exact files and functions you changed.
- The **before vs after** metrics from the new `reports/p5/p5_meta.json`:
  - `thickness_ablation.undershoot_before`
  - `thickness_ablation.undershoot_after`
  - And confirm that `"status": "SSR_QA_OK"` and `"ssr_status": "SSR_QA_OK"` still hold.
- Any design choices or thresholds you introduced for the ablation metric and why.

Work step-by-step, use `SearchText`, `ReadFile`, and `Edit` tools carefully, and avoid touching SSR shading or scene setup except where strictly necessary for the ablation experiment.
