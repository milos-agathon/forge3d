
# P1 — Light system: GPU data model + sampling stubs (no BRDF switch yet)

**Goal:** Multiple lights with compact GPU layout and sampling helpers, ready for BRDF integration.

**Backend (Rust)**

* Create `lighting/`:

  * CPU structs (`Light` with `LightType`, transforms, intensity, color, range, cone angles, area half-extents, texture handle for env).
  * GPU SSBO layout (std430), array of max N lights (default 16; cap to meet ≤512 MiB host-visible budget).
  * Light buffer ring (triple-buffered) + bind group.
* Implement TAA-friendly **blue-noise** or R2 sequence indices for light sampling (store per-frame seed).

**WGSL**

* Add `lights.wgsl`:

  ```wgsl
  struct LightGPU {
    type_: u32; // matches LightType
    intensity: f32;
    range: f32;
    color: vec3<f32>;
    dir_ws: vec3<f32>;
    pos_ws: vec3<f32>;
    cone_cos: vec2<f32>; // inner, outer
    area_half: vec2<f32>; // rect half-size or disk radius in x
  };

  @group(0) @binding(3) var<storage, read> lights: array<LightGPU>;
  @group(0) @binding(4) var<uniform> lightCounts: u32;

  fn sample_directional(i: u32) -> vec3<f32> { /* returns -dir_ws */ }
  fn sample_point(i: u32, Xi: vec2<f32>) -> vec3<f32> { /* uniform sphere */ }
  fn sample_spot(i: u32, Xi: vec2<f32>) -> vec3<f32> { /* cone sampling */ }
  fn sample_area_rect(i: u32, Xi: vec2<f32>) -> vec3<f32> { /* LTC later */ }
  fn sample_area_disk(i: u32, Xi: vec2<f32>) -> vec3<f32> { /* disk */ }
  fn sample_area_sphere(i: u32, Xi: vec2<f32>) -> vec3<f32> { /* sphere surf */ }
  ```
* Add environment light bindings (HDR cube or 2D lat-long; stub sampling function).

**Frontend**

* Python: allow `renderer.set_lights([...])` and reflect into buffer.

**Acceptance**

* Can upload multiple heterogeneous lights; frame captures show populated SSBO in a debug pass.

---

