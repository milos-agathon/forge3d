<TOON>
[TITLE]
P5 – Milestone M2: Fully initialize SSR metrics (stripe contrast + thickness ablation) in P5 harness

[ROLE]
You are a senior Rust + WGSL graphics engineer working on the forge3d P5 SSR pipeline.
You must modify the existing codebase; do NOT invent new directory structures or rename public APIs unless required.
Preserve all existing public behavior; only extend where needed.

[GOAL]
When I run the P5 SSR harnesses, the SSR pipeline must actually execute and write meaningful metrics into p5_meta.json:

1) `cargo run --release --example p5_ssr_glossy`
   → produces:
      - reports/p5/p5_ssr_glossy_reference.* (SSR OFF)
      - reports/p5/p5_ssr_glossy_spheres.* (SSR ON)
      - reports/p5/p5_meta.json with:
          ssr.status           = "SHADE_READY"
          ssr.hit_rate         > 0
          ssr.avg_steps        > 0
          ssr.miss_ibl_ratio   >= 0
          ssr.perf_ms.trace_ms > 0
          ssr.perf_ms.total_ssr_ms ≥ trace_ms
          ssr.stripe_contrast  = array[9] of floats (one per sphere)
          ssr.thickness_ablation.{undershoot_before,undershoot_after} both in [0,1]

2) `cargo run --release --example p5_ssr_thickness_ablation`
   → produces:
      - reports/p5/p5_ssr_thickness_ablation.* (thickness OFF | thickness ON)
      - same p5_meta.json updated so that:
          ssr.thickness_ablation.undershoot_after
              < ssr.thickness_ablation.undershoot_before - 0.05
          ssr.status contains "THICKNESS_OK" in its string value

[CONSTRAINTS]
- Do NOT break the viewer path; :p5 ssr-glossy must still work.
- Keep all existing SSGI keys in p5_meta.json unchanged.
- Maintain compatibility with both PNG and JPEG output (current harness may pick one via image crate; keep it working).

[CODE CONTEXT YOU MUST RESPECT]
(Names based on the current tree; adjust only if they truly differ.)

Rust:
- src/passes/ssr.rs
    - Contains SsrParams, trace/shade/fallback entry points.
    - Already has timing hooks or can be extended to measure GPU time.
- src/p5/meta.rs
    - Has write_p5_meta(..) writing the current ssr block.
- src/p5/ssr.rs
    - Builds the glossy nine-sphere scene & stripe test pattern.
- examples/p5_ssr_glossy.rs
    - Headless harness that renders reference + SSR images.
- examples/p5_ssr_thickness_ablation.rs
    - Headless harness that renders thickness OFF/ON comparison.
- src/viewer/mod.rs
    - Capture path for :p5 ssr-glossy and SSR trace mask.

WGSL:
- src/shaders/ssr/trace.wgsl
- src/shaders/ssr/shade.wgsl
- src/shaders/ssr/fallback_env.wgsl
    - These should already compile and be callable; your job is to ensure
      they are integrated and that we collect metrics from their use.

[WORK PLAN]

[M2.1] Wire SSR execution in the P5 glossy harness
- Ensure examples/p5_ssr_glossy.rs renders TWO frames in one run:
    1) Reference frame:
        - SSR DISABLED at pipeline level:
          * SsrParams.enable = false (or equivalent)
        - Render scene, save as reports/p5/p5_ssr_glossy_reference.(png|jpg).
        - Do NOT touch `ssr` metrics for this frame.
    2) SSR frame:
        - SSR ENABLED:
          * SsrParams.enable = true
          * Use same camera, resolution, and lighting as reference.
        - Call a single helper (e.g. run_ssr_pipeline(..)) that:
          * Executes trace pass
          * Executes shade pass
          * Executes fallback_env pass
        - Render final composited image to reports/p5/p5_ssr_glossy_spheres.(png|jpg).
- Make sure SSR runs even in headless mode (no viewer).

ACCEPTANCE FOR M2.1:
- After running `cargo run --release --example p5_ssr_glossy`:
    * p5_meta.json → ssr.hit_rate > 0, ssr.avg_steps > 0.
    * ssr.perf_ms.trace_ms > 0 and ssr.perf_ms.total_ssr_ms ≥ trace_ms.
    * ssr.status is NOT "UNINITIALIZED" or "SSR_UNINITIALIZED".

[M2.2] Implement stripe-contrast analysis for nine glossy spheres
Goal: compute a 9-element `ssr.stripe_contrast` array and enforce roughness monotonicity.

Implementation details:
- Add a pure-Rust image-analysis helper, e.g. in src/p5/ssr.rs or src/p5/meta.rs:
    fn analyze_stripe_contrast(
        reference_img: &DynamicImage,
        ssr_img: &DynamicImage,
    ) -> [f32; 9]
- Expected behavior:
    * Use the SSR frame as the primary measurement.
    * For each sphere i ∈ [0..9):
        - Derive a fixed screen-space ROI:
          * Use fractional coordinates so this remains stable across resolutions,
            e.g. X-range ~ [0.1 + i*Δ, 0.1 + (i+1)*Δ], Y-range a narrow horizontal band
            around the bright reflection stripe.
        - In that ROI, compute luminance L for each pixel:
              L = 0.2126*R + 0.7152*G + 0.0722*B.
        - Compute contrast:
              contrast_i = (max(L) - min(L)) / max(L, ε)
          where ε = 1e-4 to avoid division by zero.
- Write the result into `ssr.stripe_contrast` (as Vec<f32> or fixed array serialized to JSON).

Monotonicity + status:
- Assume sphere 0 is the glossiest and sphere 8 the roughest.
- Enforce:
    * contrast_0 > 0.6  (clearly visible stripe)
    * contrast_8 < 0.3  (stripe much softer)
    * contrast_i is strictly monotonically decreasing:
        contrast_0 > contrast_1 > ... > contrast_8 - 1e-3
- If all checks pass:
    * ssr.status must contain substring "SHADE_READY".
    * top-level ssr_status must equal "SSR_SHADE_READY".
- If any check fails:
    * ssr.status must contain substring "STRIPE_CONTRAST_FAIL"
      plus a concise reason string (e.g. "non_monotonic", "low_dynamic_range").
    * ssr_status must equal "SSR_STRIPE_FAIL".

ACCEPTANCE FOR M2.2:
- After running `cargo run --release --example p5_ssr_glossy`:
    * p5_meta.json:
        - ssr.stripe_contrast is exactly length 9.
        - Values are strictly decreasing.
        - ssr.status and ssr_status reflect PASS or FAIL according to the rules above.

[M2.3] Make thickness-ablation metric meaningful
Goal: have `ssr.thickness_ablation.undershoot_before` and `.undershoot_after`
reflect undershoot at depth discontinuities and show improvement when thickness is enabled.

Implementation details:
- In examples/p5_ssr_thickness_ablation.rs:
    * Render TWO frames:
        1) thickness OFF → image A (already done)
        2) thickness ON  → image B (already done)
    * After rendering, call a helper:
          fn analyze_thickness_ablation(
              no_thickness: &DynamicImage,
              with_thickness: &DynamicImage,
          ) -> (f32, f32)
- Metric suggestion (you may refine but MUST obey acceptance):
    * Choose a 1D or 2D ROI column directly under the reflective cube where undershoot occurs.
    * Compute undershoot as:
          undershoot = mean( max(0.0, ideal_color - actual_color) ) / max(ideal_color, ε)
      where ideal_color can be approximated by nearby non-undershooting pixels.
    * Value must be in [0, 1].
- Write results into:
    ssr.thickness_ablation.undershoot_before = undershoot_no_thickness
    ssr.thickness_ablation.undershoot_after  = undershoot_with_thickness
- Update ssr.status / ssr_status:
    * If undershoot_after <= undershoot_before - 0.05:
        - append "|THICKNESS_OK" to ssr.status
        - set ssr_status = "SSR_SHADE_READY_THICKNESS_OK"
    * Else:
        - append "|THICKNESS_FAIL" to ssr.status
        - set ssr_status = "SSR_THICKNESS_FAIL"

ACCEPTANCE FOR M2.3:
- After running `cargo run --release --example p5_ssr_thickness_ablation`:
    * p5_meta.json:
        - 0.0 ≤ undershoot_before ≤ 1.0
        - 0.0 ≤ undershoot_after  ≤ 1.0
        - undershoot_after < undershoot_before - 0.05
        - ssr.status contains "THICKNESS_OK"
        - ssr_status is "SSR_SHADE_READY_THICKNESS_OK"

[FINAL VERIFICATION CHECKLIST]
When you are done, ensure ALL of the following hold:

1) `cargo run --release --example p5_ssr_glossy`
   - runs without panic.
   - writes:
        - reports/p5/p5_ssr_glossy_reference.(png|jpg)
        - reports/p5/p5_ssr_glossy_spheres.(png|jpg)
        - reports/p5/p5_meta.json with:
            * ssr.hit_rate > 0
            * ssr.avg_steps > 0
            * ssr.perf_ms.trace_ms > 0
            * ssr.stripe_contrast length == 9
            * monotonic stripe contrast
            * ssr_status starts with "SSR_SHADE_READY" (if passes) or "SSR_STRIPE_FAIL" (if fails)

2) `cargo run --release --example p5_ssr_thickness_ablation`
   - runs without panic.
   - writes reports/p5/p5_ssr_thickness_ablation.(png|jpg).
   - p5_meta.json shows:
        * undershoot_before ∈ [0,1]
        * undershoot_after  ∈ [0,1]
        * undershoot_after < undershoot_before - 0.05
        * ssr_status = "SSR_SHADE_READY_THICKNESS_OK"

If any of these acceptance criteria are not satisfied, keep iterating on the implementation until they are.

[OUTPUT]
Return a unified diff (git-style) covering all edited files plus a short summary of what you changed.
</TOON>